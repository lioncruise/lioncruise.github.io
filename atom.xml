<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cassini</title>
  
  <subtitle>lioncruise&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lioncruise.github.io/"/>
  <updated>2018-01-14T14:14:31.331Z</updated>
  <id>http://lioncruise.github.io/</id>
  
  <author>
    <name>lioncruise(覃世军)</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于kubeadm部署高可用Kubernetes集群</title>
    <link href="http://lioncruise.github.io/2017/10/05/kubeadm-install-ha-k8s/"/>
    <id>http://lioncruise.github.io/2017/10/05/kubeadm-install-ha-k8s/</id>
    <published>2017-10-05T13:53:12.000Z</published>
    <updated>2018-01-14T14:14:31.331Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/Kubernetes.png" alt="k8s logo"></p><a id="more"></a><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ol><li><a href="#部署架构">部署架构</a><ol><li><a href="#概要部署架构">概要部署架构</a></li><li><a href="#详细部署架构">详细部署架构</a></li><li><a href="#主机节点清单">主机节点清单</a></li></ol></li><li><a href="#安装前准备">安装前准备</a><ol><li><a href="#版本信息">版本信息</a></li><li><a href="#所需docker镜像">所需docker镜像</a></li><li><a href="#系统设置">系统设置</a></li></ol></li><li><a href="#kubernetes安装">kubernetes安装</a><ol><li><a href="#kubernetes相关服务安装">kubernetes相关服务安装</a></li><li><a href="#docker镜像导入">docker镜像导入</a></li></ol></li><li><a href="#第一台master初始化">第一台master初始化</a><ol><li><a href="#独立etcd集群部署">独立etcd集群部署</a></li><li><a href="#kubeadm初始化">kubeadm初始化</a></li><li><a href="#flannel网络组件安装">flannel网络组件安装</a></li></ol></li><li><a href="#master集群高可用设置">master集群高可用设置</a><ol><li><a href="#复制配置">复制配置</a></li><li><a href="#修改配置">修改配置</a></li><li><a href="#验证高可用安装">验证高可用安装</a></li><li><a href="#keepalived安装配置">keepalived安装配置</a></li><li><a href="#nginx负载均衡配置">nginx负载均衡配置</a></li><li><a href="#kube-proxy配置">kube-proxy配置</a></li><li><a href="#验证master集群高可用">验证master集群高可用</a></li></ol></li><li><a href="#node节点加入高可用集群设置">node节点加入高可用集群设置</a><ol><li><a href="#kubeadm加入高可用集群">kubeadm加入高可用集群</a></li><li><a href="#部署应用验证集群">部署应用验证集群</a></li></ol></li></ol><h3 id="部署架构"><a href="#部署架构" class="headerlink" title="部署架构"></a>部署架构</h3><h4 id="概要部署架构"><a href="#概要部署架构" class="headerlink" title="概要部署架构"></a>概要部署架构</h4><p><img src="/img/ha.png" alt="ha logo"></p><ul><li>kubernetes高可用的核心架构是master的高可用，kubectl、客户端以及nodes访问load balancer实现高可用。</li></ul><hr><p><a href="#目录">返回目录</a></p><h4 id="详细部署架构"><a href="#详细部署架构" class="headerlink" title="详细部署架构"></a>详细部署架构</h4><p><img src="/img/k8s-ha.png" alt="k8s ha"></p><ul><li>kubernetes组件说明</li></ul><blockquote><p>kube-apiserver：集群核心，集群API接口、集群各个组件通信的中枢；集群安全控制；</p><p>etcd：集群的数据中心，用于存放集群的配置以及状态信息，非常重要，如果数据丢失那么集群将无法恢复；因此高可用集群部署首先就是etcd是高可用集群；</p><p>kube-scheduler：集群Pod的调度中心；默认kubeadm安装情况下–leader-elect参数已经设置为true，保证master集群中只有一个kube-scheduler处于活跃状态；</p><p>kube-controller-manager：集群状态管理器，当集群状态与期望不同时，kcm会努力让集群恢复期望状态，比如：当一个pod死掉，kcm会努力新建一个pod来恢复对应replicas set期望的状态；默认kubeadm安装情况下–leader-elect参数已经设置为true，保证master集群中只有一个kube-controller-manager处于活跃状态；</p><p>kubelet: kubernetes node agent，负责与node上的docker engine打交道；</p><p>kube-proxy: 每个node上一个，负责service vip到endpoint pod的流量转发，当前主要通过设置iptables规则实现。</p></blockquote><ul><li>负载均衡</li></ul><blockquote><p>keepalived集群设置一个虚拟ip地址，虚拟ip地址指向k8s-master1、k8s-master2、k8s-master3。</p><p>nginx用于k8s-master1、k8s-master2、k8s-master3的apiserver的负载均衡。外部kubectl以及nodes访问apiserver的时候就可以用过keepalived的虚拟ip(192.168.60.80)以及nginx端口(8443)访问master集群的apiserver。</p></blockquote><hr><p><a href="#目录">返回目录</a></p><h4 id="主机节点清单"><a href="#主机节点清单" class="headerlink" title="主机节点清单"></a>主机节点清单</h4><table><thead><tr><th style="text-align:left">主机名</th><th style="text-align:left">IP地址</th><th style="text-align:left">说明</th><th style="text-align:left">组件 </th></tr></thead><tbody><tr><td style="text-align:left"> k8s-master1</td><td style="text-align:left">192.168.60.71</td><td style="text-align:left">master节点1</td><td style="text-align:left">keepalived、nginx、etcd、kubelet、kube-apiserver、kube-scheduler、kube-proxy、kube-dashboard、heapster</td></tr><tr><td style="text-align:left"> k8s-master2</td><td style="text-align:left">192.168.60.72</td><td style="text-align:left">master节点2</td><td style="text-align:left">keepalived、nginx、etcd、kubelet、kube-apiserver、kube-scheduler、kube-proxy、kube-dashboard、heapster</td></tr><tr><td style="text-align:left"> k8s-master3</td><td style="text-align:left">192.168.60.73</td><td style="text-align:left">master节点3</td><td style="text-align:left">keepalived、nginx、etcd、kubelet、kube-apiserver、kube-scheduler、kube-proxy、kube-dashboard、heapster</td></tr><tr><td style="text-align:left"> 无</td><td style="text-align:left">192.168.60.80</td><td style="text-align:left">keepalived虚拟IP</td><td style="text-align:left">无</td></tr><tr><td style="text-align:left"> k8s-node1 ~ 8</td><td style="text-align:left">192.168.60.81 ~ 88</td><td style="text-align:left">8个node节点</td><td style="text-align:left">kubelet、kube-proxy</td></tr></tbody></table><hr><p><a href="#目录">返回目录</a></p><h3 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h3><h4 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h4><ul><li>Linux版本：CentOS 7.3.1611</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/redhat-release </span><br><span class="line">CentOS Linux release 7.3.1611 (Core)</span><br></pre></td></tr></table></figure><ul><li>docker版本：1.12.6</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:      1.12.6</span><br><span class="line"> API version:  1.24</span><br><span class="line"> Go version:   go1.6.4</span><br><span class="line"> Git commit:   78d1802</span><br><span class="line"> Built:        Tue Jan 10 20:20:01 2017</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:      1.12.6</span><br><span class="line"> API version:  1.24</span><br><span class="line"> Go version:   go1.6.4</span><br><span class="line"> Git commit:   78d1802</span><br><span class="line"> Built:        Tue Jan 10 20:20:01 2017</span><br><span class="line"> OS/Arch:      linux/amd64</span><br></pre></td></tr></table></figure><ul><li>kubeadm版本：v1.7.0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm version</span><br><span class="line">kubeadm version: &amp;version.Info&#123;Major:&quot;1&quot;, Minor:&quot;7&quot;, GitVersion:&quot;v1.7.0&quot;, GitCommit:&quot;d3ada0119e776222f11ec7945e6d860061339aad&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2017-06-29T22:55:19Z&quot;, GoVersion:&quot;go1.8.3&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;&#125;</span><br></pre></td></tr></table></figure><ul><li>kubelet版本：v1.7.0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubelet --version</span><br><span class="line">Kubernetes v1.7.0</span><br></pre></td></tr></table></figure><hr><p><a href="#目录">返回目录</a></p><h4 id="所需docker镜像"><a href="#所需docker镜像" class="headerlink" title="所需docker镜像"></a>所需docker镜像</h4><ul><li>国内可以使用daocloud加速器下载相关镜像，然后通过docker save、docker load把本地下载的镜像放到kubernetes集群的所在机器上，daocloud加速器链接如下：</li></ul><p><a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">https://www.daocloud.io/mirror#accelerator-doc</a></p><ul><li>在本机MacOSX上pull相关docker镜像</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull gcr.io/google_containers/kube-proxy-amd64:v1.7.0</span><br><span class="line">$ docker pull gcr.io/google_containers/kube-apiserver-amd64:v1.7.0</span><br><span class="line">$ docker pull gcr.io/google_containers/kube-controller-manager-amd64:v1.7.0</span><br><span class="line">$ docker pull gcr.io/google_containers/kube-scheduler-amd64:v1.7.0</span><br><span class="line">$ docker pull gcr.io/google_containers/k8s-dns-sidecar-amd64:1.14.4</span><br><span class="line">$ docker pull gcr.io/google_containers/k8s-dns-kube-dns-amd64:1.14.4</span><br><span class="line">$ docker pull gcr.io/google_containers/k8s-dns-dnsmasq-nanny-amd64:1.14.4</span><br><span class="line">$ docker pull nginx:latest</span><br><span class="line">$ docker pull gcr.io/google_containers/kubernetes-dashboard-amd64:v1.6.1</span><br><span class="line">$ docker pull quay.io/coreos/flannel:v0.7.1-amd64</span><br><span class="line">$ docker pull gcr.io/google_containers/heapster-amd64:v1.3.0</span><br><span class="line">$ docker pull gcr.io/google_containers/etcd-amd64:3.0.17</span><br><span class="line">$ docker pull gcr.io/google_containers/heapster-grafana-amd64:v4.0.2</span><br><span class="line">$ docker pull gcr.io/google_containers/heapster-influxdb-amd64:v1.1.1</span><br><span class="line">$ docker pull gcr.io/google_containers/pause-amd64:3.0</span><br></pre></td></tr></table></figure><ul><li>在本机MacOSX上获取代码，并进入代码目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/cookeem/kubeadm-ha</span><br><span class="line">$ cd kubeadm-ha</span><br></pre></td></tr></table></figure><ul><li>在本机MacOSX上把相关docker镜像保存成文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p docker-images</span><br><span class="line">$ docker save -o docker-images/kube-proxy-amd64  gcr.io/google_containers/kube-proxy-amd64:v1.7.0</span><br><span class="line">$ docker save -o docker-images/kube-apiserver-amd64  gcr.io/google_containers/kube-apiserver-amd64:v1.7.0</span><br><span class="line">$ docker save -o docker-images/kube-controller-manager-amd64  gcr.io/google_containers/kube-controller-manager-amd64:v1.7.0</span><br><span class="line">$ docker save -o docker-images/kube-scheduler-amd64  gcr.io/google_containers/kube-scheduler-amd64:v1.7.0</span><br><span class="line">$ docker save -o docker-images/k8s-dns-sidecar-amd64  gcr.io/google_containers/k8s-dns-sidecar-amd64:1.14.4</span><br><span class="line">$ docker save -o docker-images/k8s-dns-kube-dns-amd64  gcr.io/google_containers/k8s-dns-kube-dns-amd64:1.14.4</span><br><span class="line">$ docker save -o docker-images/k8s-dns-dnsmasq-nanny-amd64  gcr.io/google_containers/k8s-dns-dnsmasq-nanny-amd64:1.14.4</span><br><span class="line">$ docker save -o docker-images/heapster-grafana-amd64  gcr.io/google_containers/heapster-grafana-amd64:v4.2.0</span><br><span class="line">$ docker save -o docker-images/nginx  nginx:latest</span><br><span class="line">$ docker save -o docker-images/kubernetes-dashboard-amd64  gcr.io/google_containers/kubernetes-dashboard-amd64:v1.6.1</span><br><span class="line">$ docker save -o docker-images/flannel  quay.io/coreos/flannel:v0.7.1-amd64</span><br><span class="line">$ docker save -o docker-images/heapster-amd64  gcr.io/google_containers/heapster-amd64:v1.3.0</span><br><span class="line">$ docker save -o docker-images/etcd-amd64  gcr.io/google_containers/etcd-amd64:3.0.17</span><br><span class="line">$ docker save -o docker-images/heapster-grafana-amd64  gcr.io/google_containers/heapster-grafana-amd64:v4.0.2</span><br><span class="line">$ docker save -o docker-images/heapster-influxdb-amd64  gcr.io/google_containers/heapster-influxdb-amd64:v1.1.1</span><br><span class="line">$ docker save -o docker-images/pause-amd64  gcr.io/google_containers/pause-amd64:3.0</span><br></pre></td></tr></table></figure><ul><li>在本机MacOSX上把代码以及docker镜像复制到所有节点上</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ scp -r * root@k8s-master1:/root/kubeadm-ha</span><br><span class="line">$ scp -r * root@k8s-master2:/root/kubeadm-ha</span><br><span class="line">$ scp -r * root@k8s-master3:/root/kubeadm-ha</span><br><span class="line">$ scp -r * root@k8s-node1:/root/kubeadm-ha</span><br><span class="line">$ scp -r * root@k8s-node2:/root/kubeadm-ha</span><br><span class="line">$ scp -r * root@k8s-node3:/root/kubeadm-ha</span><br><span class="line">$ scp -r * root@k8s-node4:/root/kubeadm-ha</span><br><span class="line">$ scp -r * root@k8s-node5:/root/kubeadm-ha</span><br><span class="line">$ scp -r * root@k8s-node6:/root/kubeadm-ha</span><br><span class="line">$ scp -r * root@k8s-node7:/root/kubeadm-ha</span><br><span class="line">$ scp -r * root@k8s-node8:/root/kubeadm-ha</span><br></pre></td></tr></table></figure><hr><p><a href="#目录">返回目录</a></p><h4 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h4><ul><li><p>以下在kubernetes所有节点上都是使用root用户进行操作</p></li><li><p>在kubernetes所有节点上增加kubernetes仓库 </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg</span><br><span class="line">        https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li>在kubernetes所有节点上进行系统更新</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum update -y</span><br></pre></td></tr></table></figure><ul><li>在kubernetes所有节点上关闭防火墙</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl disable firewalld &amp;&amp; systemctl stop firewalld &amp;&amp; systemctl status firewalld</span><br></pre></td></tr></table></figure><ul><li>在kubernetes所有节点上设置SELINUX为permissive模式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/selinux/config</span><br><span class="line">SELINUX=permissive</span><br></pre></td></tr></table></figure><ul><li>在kubernetes所有节点上设置iptables参数，否则kubeadm init会提示错误</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br></pre></td></tr></table></figure><ul><li>在kubernetes所有节点上重启主机</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ reboot</span><br></pre></td></tr></table></figure><hr><p><a href="#目录">返回目录</a></p><h3 id="kubernetes安装"><a href="#kubernetes安装" class="headerlink" title="kubernetes安装"></a>kubernetes安装</h3><h4 id="kubernetes相关服务安装"><a href="#kubernetes相关服务安装" class="headerlink" title="kubernetes相关服务安装"></a>kubernetes相关服务安装</h4><ul><li>在kubernetes所有节点上验证SELINUX模式，必须保证SELINUX为permissive模式，否则kubernetes启动会出现各种异常</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ getenforce</span><br><span class="line">Permissive</span><br></pre></td></tr></table></figure><ul><li>在kubernetes所有节点上安装并启动kubernetes </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ yum search docker --showduplicates</span><br><span class="line">$ yum install docker-1.12.6-16.el7.centos.x86_64</span><br><span class="line"></span><br><span class="line">$ yum search kubelet --showduplicates</span><br><span class="line">$ yum install kubelet-1.7.0-0.x86_64</span><br><span class="line"></span><br><span class="line">$ yum search kubeadm --showduplicates</span><br><span class="line">$ yum install kubeadm-1.7.0-0.x86_64</span><br><span class="line"></span><br><span class="line">$ yum search kubernetes-cni --showduplicates</span><br><span class="line">$ yum install kubernetes-cni-0.5.1-0.x86_64</span><br><span class="line"></span><br><span class="line">$ systemctl enable docker &amp;&amp; systemctl start docker</span><br><span class="line">$ systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure><hr><p><a href="#目录">返回目录</a></p><h4 id="docker镜像导入"><a href="#docker镜像导入" class="headerlink" title="docker镜像导入"></a>docker镜像导入</h4><ul><li>在kubernetes所有节点上导入docker镜像 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ docker load -i /root/kubeadm-ha/docker-images/etcd-amd64</span><br><span class="line">$ docker load -i /root/kubeadm-ha/docker-images/flannel</span><br><span class="line">$ docker load -i /root/kubeadm-ha/docker-images/heapster-amd64</span><br><span class="line">$ docker load -i /root/kubeadm-ha/docker-images/heapster-grafana-amd64</span><br><span class="line">$ docker load -i /root/kubeadm-ha/docker-images/heapster-influxdb-amd64</span><br><span class="line">$ docker load -i /root/kubeadm-ha/docker-images/k8s-dns-dnsmasq-nanny-amd64</span><br><span class="line">$ docker load -i /root/kubeadm-ha/docker-images/k8s-dns-kube-dns-amd64</span><br><span class="line">$ docker load -i /root/kubeadm-ha/docker-images/k8s-dns-sidecar-amd64</span><br><span class="line">$ docker load -i /root/kubeadm-ha/docker-images/kube-apiserver-amd64</span><br><span class="line">$ docker load -i /root/kubeadm-ha/docker-images/kube-controller-manager-amd64</span><br><span class="line">$ docker load -i /root/kubeadm-ha/docker-images/kube-proxy-amd64</span><br><span class="line">$ docker load -i /root/kubeadm-ha/docker-images/kubernetes-dashboard-amd64</span><br><span class="line">$ docker load -i /root/kubeadm-ha/docker-images/kube-scheduler-amd64</span><br><span class="line">$ docker load -i /root/kubeadm-ha/docker-images/pause-amd64</span><br><span class="line">$ docker load -i /root/kubeadm-ha/docker-images/nginx</span><br><span class="line"></span><br><span class="line">$ docker images</span><br><span class="line">REPOSITORY                                               TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">gcr.io/google_containers/kube-proxy-amd64                v1.7.0              d2d44013d0f8        4 days ago          114.7 MB</span><br><span class="line">gcr.io/google_containers/kube-apiserver-amd64            v1.7.0              f0d4b746fb2b        4 days ago          185.2 MB</span><br><span class="line">gcr.io/google_containers/kube-controller-manager-amd64   v1.7.0              36bf73ed0632        4 days ago          137 MB</span><br><span class="line">gcr.io/google_containers/kube-scheduler-amd64            v1.7.0              5c9a7f60a95c        4 days ago          77.16 MB</span><br><span class="line">gcr.io/google_containers/k8s-dns-sidecar-amd64           1.14.4              38bac66034a6        7 days ago          41.81 MB</span><br><span class="line">gcr.io/google_containers/k8s-dns-kube-dns-amd64          1.14.4              a8e00546bcf3        7 days ago          49.38 MB</span><br><span class="line">gcr.io/google_containers/k8s-dns-dnsmasq-nanny-amd64     1.14.4              f7f45b9cb733        7 days ago          41.41 MB</span><br><span class="line">nginx                                                    latest              958a7ae9e569        4 weeks ago         109.4 MB</span><br><span class="line">gcr.io/google_containers/kubernetes-dashboard-amd64      v1.6.1              71dfe833ce74        6 weeks ago         134.4 MB</span><br><span class="line">quay.io/coreos/flannel                                   v0.7.1-amd64        cd4ae0be5e1b        10 weeks ago        77.76 MB</span><br><span class="line">gcr.io/google_containers/heapster-amd64                  v1.3.0              f9d33bedfed3        3 months ago        68.11 MB</span><br><span class="line">gcr.io/google_containers/etcd-amd64                      3.0.17              243830dae7dd        4 months ago        168.9 MB</span><br><span class="line">gcr.io/google_containers/heapster-grafana-amd64          v4.0.2              a1956d2a1a16        5 months ago        131.5 MB</span><br><span class="line">gcr.io/google_containers/heapster-influxdb-amd64         v1.1.1              d3fccbedd180        5 months ago        11.59 MB</span><br><span class="line">gcr.io/google_containers/pause-amd64                     3.0                 99e59f495ffa        14 months ago       746.9 kB</span><br></pre></td></tr></table></figure><hr><p><a href="#目录">返回目录</a></p><h3 id="第一台master初始化"><a href="#第一台master初始化" class="headerlink" title="第一台master初始化"></a>第一台master初始化</h3><h4 id="独立etcd集群部署"><a href="#独立etcd集群部署" class="headerlink" title="独立etcd集群部署"></a>独立etcd集群部署</h4><ul><li>在k8s-master1节点上以docker方式启动etcd集群</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop etcd &amp;&amp; docker rm etcd</span><br><span class="line">$ rm -rf /var/lib/etcd-cluster</span><br><span class="line">$ mkdir -p /var/lib/etcd-cluster</span><br><span class="line">$ docker run -d \</span><br><span class="line">--restart always \</span><br><span class="line">-v /etc/ssl/certs:/etc/ssl/certs \</span><br><span class="line">-v /var/lib/etcd-cluster:/var/lib/etcd \</span><br><span class="line">-p 4001:4001 \</span><br><span class="line">-p 2380:2380 \</span><br><span class="line">-p 2379:2379 \</span><br><span class="line">--name etcd \</span><br><span class="line">gcr.io/google_containers/etcd-amd64:3.0.17 \</span><br><span class="line">etcd --name=etcd0 \</span><br><span class="line">--advertise-client-urls=http://192.168.60.71:2379,http://192.168.60.71:4001 \</span><br><span class="line">--listen-client-urls=http://0.0.0.0:2379,http://0.0.0.0:4001 \</span><br><span class="line">--initial-advertise-peer-urls=http://192.168.60.71:2380 \</span><br><span class="line">--listen-peer-urls=http://0.0.0.0:2380 \</span><br><span class="line">--initial-cluster-token=9477af68bbee1b9ae037d6fd9e7efefd \</span><br><span class="line">--initial-cluster=etcd0=http://192.168.60.71:2380,etcd1=http://192.168.60.72:2380,etcd2=http://192.168.60.73:2380 \</span><br><span class="line">--initial-cluster-state=new \</span><br><span class="line">--auto-tls \</span><br><span class="line">--peer-auto-tls \</span><br><span class="line">--data-dir=/var/lib/etcd</span><br></pre></td></tr></table></figure><ul><li>在k8s-master2节点上以docker方式启动etcd集群</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop etcd &amp;&amp; docker rm etcd</span><br><span class="line">$ rm -rf /var/lib/etcd-cluster</span><br><span class="line">$ mkdir -p /var/lib/etcd-cluster</span><br><span class="line">$ docker run -d \</span><br><span class="line">--restart always \</span><br><span class="line">-v /etc/ssl/certs:/etc/ssl/certs \</span><br><span class="line">-v /var/lib/etcd-cluster:/var/lib/etcd \</span><br><span class="line">-p 4001:4001 \</span><br><span class="line">-p 2380:2380 \</span><br><span class="line">-p 2379:2379 \</span><br><span class="line">--name etcd \</span><br><span class="line">gcr.io/google_containers/etcd-amd64:3.0.17 \</span><br><span class="line">etcd --name=etcd1 \</span><br><span class="line">--advertise-client-urls=http://192.168.60.72:2379,http://192.168.60.72:4001 \</span><br><span class="line">--listen-client-urls=http://0.0.0.0:2379,http://0.0.0.0:4001 \</span><br><span class="line">--initial-advertise-peer-urls=http://192.168.60.72:2380 \</span><br><span class="line">--listen-peer-urls=http://0.0.0.0:2380 \</span><br><span class="line">--initial-cluster-token=9477af68bbee1b9ae037d6fd9e7efefd \</span><br><span class="line">--initial-cluster=etcd0=http://192.168.60.71:2380,etcd1=http://192.168.60.72:2380,etcd2=http://192.168.60.73:2380 \</span><br><span class="line">--initial-cluster-state=new \</span><br><span class="line">--auto-tls \</span><br><span class="line">--peer-auto-tls \</span><br><span class="line">--data-dir=/var/lib/etcd</span><br></pre></td></tr></table></figure><ul><li>在k8s-master3节点上以docker方式启动etcd集群</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop etcd &amp;&amp; docker rm etcd</span><br><span class="line">$ rm -rf /var/lib/etcd-cluster</span><br><span class="line">$ mkdir -p /var/lib/etcd-cluster</span><br><span class="line">$ docker run -d \</span><br><span class="line">--restart always \</span><br><span class="line">-v /etc/ssl/certs:/etc/ssl/certs \</span><br><span class="line">-v /var/lib/etcd-cluster:/var/lib/etcd \</span><br><span class="line">-p 4001:4001 \</span><br><span class="line">-p 2380:2380 \</span><br><span class="line">-p 2379:2379 \</span><br><span class="line">--name etcd \</span><br><span class="line">gcr.io/google_containers/etcd-amd64:3.0.17 \</span><br><span class="line">etcd --name=etcd2 \</span><br><span class="line">--advertise-client-urls=http://192.168.60.73:2379,http://192.168.60.73:4001 \</span><br><span class="line">--listen-client-urls=http://0.0.0.0:2379,http://0.0.0.0:4001 \</span><br><span class="line">--initial-advertise-peer-urls=http://192.168.60.73:2380 \</span><br><span class="line">--listen-peer-urls=http://0.0.0.0:2380 \</span><br><span class="line">--initial-cluster-token=9477af68bbee1b9ae037d6fd9e7efefd \</span><br><span class="line">--initial-cluster=etcd0=http://192.168.60.71:2380,etcd1=http://192.168.60.72:2380,etcd2=http://192.168.60.73:2380 \</span><br><span class="line">--initial-cluster-state=new \</span><br><span class="line">--auto-tls \</span><br><span class="line">--peer-auto-tls \</span><br><span class="line">--data-dir=/var/lib/etcd</span><br></pre></td></tr></table></figure><ul><li>在k8s-master1、k8s-master2、k8s-master3上检查etcd启动状态</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -ti etcd ash</span><br><span class="line"></span><br><span class="line">$ etcdctl member list</span><br><span class="line">1a32c2d3f1abcad0: name=etcd2 peerURLs=http://192.168.60.73:2380 clientURLs=http://192.168.60.73:2379,http://192.168.60.73:4001 isLeader=false</span><br><span class="line">1da4f4e8b839cb79: name=etcd1 peerURLs=http://192.168.60.72:2380 clientURLs=http://192.168.60.72:2379,http://192.168.60.72:4001 isLeader=false</span><br><span class="line">4238bcb92d7f2617: name=etcd0 peerURLs=http://192.168.60.71:2380 clientURLs=http://192.168.60.71:2379,http://192.168.60.71:4001 isLeader=true</span><br><span class="line"></span><br><span class="line">$ etcdctl cluster-health</span><br><span class="line">member 1a32c2d3f1abcad0 is healthy: got healthy result from http://192.168.60.73:2379</span><br><span class="line">member 1da4f4e8b839cb79 is healthy: got healthy result from http://192.168.60.72:2379</span><br><span class="line">member 4238bcb92d7f2617 is healthy: got healthy result from http://192.168.60.71:2379</span><br><span class="line">cluster is healthy</span><br><span class="line"></span><br><span class="line">$ exit</span><br></pre></td></tr></table></figure><hr><p><a href="#目录">返回目录</a></p><h4 id="kubeadm初始化"><a href="#kubeadm初始化" class="headerlink" title="kubeadm初始化"></a>kubeadm初始化</h4><ul><li>在k8s-master1上修改kubeadm-init-v1.7.x.yaml文件，设置etcd.endpoints的${HOST_IP}为k8s-master1、k8s-master2、k8s-master3的IP地址。设置apiServerCertSANs的${HOST_IP}为k8s-master1、k8s-master2、k8s-master3的IP地址，${HOST_NAME}为k8s-master1、k8s-master2、k8s-master3，${VIRTUAL_IP}为keepalived的虚拟IP地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ vi /root/kubeadm-ha/kubeadm-init-v1.7.x.yaml </span><br><span class="line">apiVersion: kubeadm.k8s.io/v1alpha1</span><br><span class="line">kind: MasterConfiguration</span><br><span class="line">kubernetesVersion: v1.7.0</span><br><span class="line">networking:</span><br><span class="line">  podSubnet: 10.244.0.0/16</span><br><span class="line">apiServerCertSANs:</span><br><span class="line">- k8s-master1</span><br><span class="line">- k8s-master2</span><br><span class="line">- k8s-master3</span><br><span class="line">- 192.168.60.71</span><br><span class="line">- 192.168.60.72</span><br><span class="line">- 192.168.60.73</span><br><span class="line">- 192.168.60.80</span><br><span class="line">etcd:</span><br><span class="line">  endpoints:</span><br><span class="line">  - http://192.168.60.71:2379</span><br><span class="line">  - http://192.168.60.72:2379</span><br><span class="line">  - http://192.168.60.73:2379</span><br></pre></td></tr></table></figure><ul><li>如果使用kubeadm初始化集群，启动过程可能会卡在以下位置，那么可能是因为cgroup-driver参数与docker的不一致引起</li><li>[apiclient] Created API client, waiting for the control plane to become ready</li><li>journalctl -t kubelet -S ‘2017-06-08’查看日志，发现如下错误</li><li>error: failed to run Kubelet: failed to create kubelet: misconfiguration: kubelet cgroup driver: “systemd”</li><li>需要修改KUBELET_CGROUP_ARGS=–cgroup-driver=systemd为KUBELET_CGROUP_ARGS=–cgroup-driver=cgroupfs</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/systemd/system/kubelet.service.d/10-kubeadm.conf</span><br><span class="line">#Environment=&quot;KUBELET_CGROUP_ARGS=--cgroup-driver=systemd&quot;</span><br><span class="line">Environment=&quot;KUBELET_CGROUP_ARGS=--cgroup-driver=cgroupfs&quot;</span><br><span class="line"></span><br><span class="line">$ systemctl daemon-reload &amp;&amp; systemctl restart kubelet</span><br></pre></td></tr></table></figure><ul><li>在k8s-master1上使用kubeadm初始化kubernetes集群，连接外部etcd集群</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm init --config=/root/kubeadm-ha/kubeadm-init-v1.7.x.yaml</span><br></pre></td></tr></table></figure><ul><li>在k8s-master1上修改kube-apiserver.yaml的admission-control，v1.7.0使用了NodeRestriction等安全检查控制，务必设置成v1.6.x推荐的admission-control配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/kubernetes/manifests/kube-apiserver.yaml</span><br><span class="line">#    - --admission-control=Initializers,NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,ResourceQuota</span><br><span class="line">    - --admission-control=NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,DefaultStorageClass,ResourceQuota,DefaultTolerationSeconds</span><br></pre></td></tr></table></figure><ul><li>在k8s-master1上重启docker kubelet服务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl restart docker kubelet</span><br></pre></td></tr></table></figure><ul><li>在k8s-master1上设置kubectl的环境变量KUBECONFIG，连接kubelet</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vi ~/.bashrc</span><br><span class="line">export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">$ source ~/.bashrc</span><br></pre></td></tr></table></figure><hr><p><a href="#目录">返回目录</a></p><h4 id="flannel网络组件安装"><a href="#flannel网络组件安装" class="headerlink" title="flannel网络组件安装"></a>flannel网络组件安装</h4><ul><li>在k8s-master1上安装flannel pod网络组件，必须安装网络组件，否则kube-dns pod会一直处于ContainerCreating</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f /root/kubeadm-ha/kube-flannel</span><br><span class="line">clusterrole &quot;flannel&quot; created</span><br><span class="line">clusterrolebinding &quot;flannel&quot; created</span><br><span class="line">serviceaccount &quot;flannel&quot; created</span><br><span class="line">configmap &quot;kube-flannel-cfg&quot; created</span><br><span class="line">daemonset &quot;kube-flannel-ds&quot; created</span><br></pre></td></tr></table></figure><ul><li>在k8s-master1上验证kube-dns成功启动，大概等待3分钟，验证所有pods的状态为Running</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods --all-namespaces -o wide</span><br><span class="line">NAMESPACE     NAME                                 READY     STATUS    RESTARTS   AGE       IP              NODE</span><br><span class="line">kube-system   kube-apiserver-k8s-master1           1/1       Running   0          3m        192.168.60.71   k8s-master1</span><br><span class="line">kube-system   kube-controller-manager-k8s-master1  1/1       Running   0          3m        192.168.60.71   k8s-master1</span><br><span class="line">kube-system   kube-dns-3913472980-k9mt6            3/3       Running   0          4m        10.244.0.104    k8s-master1</span><br><span class="line">kube-system   kube-flannel-ds-3hhjd                2/2       Running   0          1m        192.168.60.71   k8s-master1</span><br><span class="line">kube-system   kube-proxy-rzq3t                     1/1       Running   0          4m        192.168.60.71   k8s-master1</span><br><span class="line">kube-system   kube-scheduler-k8s-master1           1/1       Running   0          3m        192.168.60.71   k8s-master1</span><br></pre></td></tr></table></figure><hr><p><a href="#目录">返回目录</a></p><h3 id="master集群高可用设置"><a href="#master集群高可用设置" class="headerlink" title="master集群高可用设置"></a>master集群高可用设置</h3><h4 id="复制配置"><a href="#复制配置" class="headerlink" title="复制配置"></a>复制配置</h4><ul><li>在k8s-master1上把/etc/kubernetes/复制到k8s-master2、k8s-master3</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r /etc/kubernetes/ k8s-master2:/etc/</span><br><span class="line">scp -r /etc/kubernetes/ k8s-master3:/etc/</span><br></pre></td></tr></table></figure><ul><li>在k8s-master2、k8s-master3上重启kubelet服务，并检查kubelet服务状态为active (running)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl daemon-reload &amp;&amp; systemctl restart kubelet</span><br><span class="line"></span><br><span class="line">$ systemctl status kubelet</span><br><span class="line">● kubelet.service - kubelet: The Kubernetes Node Agent</span><br><span class="line">   Loaded: loaded (/etc/systemd/system/kubelet.service; enabled; vendor preset: disabled)</span><br><span class="line">  Drop-In: /etc/systemd/system/kubelet.service.d</span><br><span class="line">           └─10-kubeadm.conf</span><br><span class="line">   Active: active (running) since Tue 2017-06-27 16:24:22 CST; 1 day 17h ago</span><br><span class="line">     Docs: http://kubernetes.io/docs/</span><br><span class="line"> Main PID: 2780 (kubelet)</span><br><span class="line">   Memory: 92.9M</span><br><span class="line">   CGroup: /system.slice/kubelet.service</span><br><span class="line">           ├─2780 /usr/bin/kubelet --kubeconfig=/etc/kubernetes/kubelet.conf --require-...</span><br><span class="line">           └─2811 journalctl -k -f</span><br></pre></td></tr></table></figure><ul><li>在k8s-master2、k8s-master3上设置kubectl的环境变量KUBECONFIG，连接kubelet</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vi ~/.bashrc</span><br><span class="line">export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">$ source ~/.bashrc</span><br></pre></td></tr></table></figure><ul><li>在k8s-master2、k8s-master3检测节点状态，发现节点已经加进来</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes -o wide</span><br><span class="line">NAME          STATUS    AGE       VERSION   EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION</span><br><span class="line">k8s-master1   Ready     26m       v1.7.0    &lt;none&gt;        CentOS Linux 7 (Core)   3.10.0-514.6.1.el7.x86_64</span><br><span class="line">k8s-master2   Ready     2m        v1.7.0    &lt;none&gt;        CentOS Linux 7 (Core)   3.10.0-514.21.1.el7.x86_64</span><br><span class="line">k8s-master3   Ready     2m        v1.7.0    &lt;none&gt;        CentOS Linux 7 (Core)   3.10.0-514.21.1.el7.x86_64</span><br></pre></td></tr></table></figure><hr><p><a href="#目录">返回目录</a></p><h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><ul><li>在k8s-master2、k8s-master3上修改kube-apiserver.yaml的配置，${HOST_IP}改为本机IP</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/kubernetes/manifests/kube-apiserver.yaml</span><br><span class="line">    - --advertise-address=$&#123;HOST_IP&#125;</span><br></pre></td></tr></table></figure><ul><li>在k8s-master2和k8s-master3上的修改kubelet.conf设置，${HOST_IP}改为本机IP</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/kubernetes/kubelet.conf</span><br><span class="line">server: https://$&#123;HOST_IP&#125;:6443</span><br></pre></td></tr></table></figure><ul><li>在k8s-master2和k8s-master3上修改admin.conf，${HOST_IP}修改为本机IP地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/kubernetes/admin.conf</span><br><span class="line">    server: https://$&#123;HOST_IP&#125;:6443</span><br></pre></td></tr></table></figure><ul><li>在k8s-master2和k8s-master3上修改controller-manager.conf，${HOST_IP}修改为本机IP地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/kubernetes/controller-manager.conf</span><br><span class="line">    server: https://$&#123;HOST_IP&#125;:6443</span><br></pre></td></tr></table></figure><ul><li>在k8s-master2和k8s-master3上修改scheduler.conf，${HOST_IP}修改为本机IP地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/kubernetes/scheduler.conf</span><br><span class="line">    server: https://$&#123;HOST_IP&#125;:6443</span><br></pre></td></tr></table></figure><ul><li>在k8s-master1、k8s-master2、k8s-master3上重启所有服务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl daemon-reload &amp;&amp; systemctl restart docker kubelet</span><br></pre></td></tr></table></figure><hr><p><a href="#目录">返回目录</a></p><h4 id="验证高可用安装"><a href="#验证高可用安装" class="headerlink" title="验证高可用安装"></a>验证高可用安装</h4><ul><li>在k8s-master1、k8s-master2、k8s-master3任意节点上检测服务启动情况，发现apiserver、controller-manager、kube-scheduler、proxy、flannel已经在k8s-master1、k8s-master2、k8s-master3成功启动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pod --all-namespaces -o wide | grep k8s-master2</span><br><span class="line">kube-system   kube-apiserver-k8s-master2              1/1       Running   1          55s       192.168.60.72   k8s-master2</span><br><span class="line">kube-system   kube-controller-manager-k8s-master2     1/1       Running   2          18m       192.168.60.72   k8s-master2</span><br><span class="line">kube-system   kube-flannel-ds-t8gkh                   2/2       Running   4          18m       192.168.60.72   k8s-master2</span><br><span class="line">kube-system   kube-proxy-bpgqw                        1/1       Running   1          18m       192.168.60.72   k8s-master2</span><br><span class="line">kube-system   kube-scheduler-k8s-master2              1/1       Running   2          18m       192.168.60.72   k8s-master2</span><br><span class="line"></span><br><span class="line">$ kubectl get pod --all-namespaces -o wide | grep k8s-master3</span><br><span class="line">kube-system   kube-apiserver-k8s-master3              1/1       Running   1          1m        192.168.60.73   k8s-master3</span><br><span class="line">kube-system   kube-controller-manager-k8s-master3     1/1       Running   2          18m       192.168.60.73   k8s-master3</span><br><span class="line">kube-system   kube-flannel-ds-tmqmx                   2/2       Running   4          18m       192.168.60.73   k8s-master3</span><br><span class="line">kube-system   kube-proxy-4stg3                        1/1       Running   1          18m       192.168.60.73   k8s-master3</span><br><span class="line">kube-system   kube-scheduler-k8s-master3              1/1       Running   2          18m       192.168.60.73   k8s-master3</span><br></pre></td></tr></table></figure><ul><li>在k8s-master1、k8s-master2、k8s-master3任意节点上通过kubectl logs检查各个controller-manager和scheduler的leader election结果，可以发现只有一个节点有效表示选举正常</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl logs -n kube-system kube-controller-manager-k8s-master1</span><br><span class="line">$ kubectl logs -n kube-system kube-controller-manager-k8s-master2</span><br><span class="line">$ kubectl logs -n kube-system kube-controller-manager-k8s-master3</span><br><span class="line"></span><br><span class="line">$ kubectl logs -n kube-system kube-scheduler-k8s-master1</span><br><span class="line">$ kubectl logs -n kube-system kube-scheduler-k8s-master2</span><br><span class="line">$ kubectl logs -n kube-system kube-scheduler-k8s-master3</span><br></pre></td></tr></table></figure><ul><li>在k8s-master1、k8s-master2、k8s-master3任意节点上查看deployment的情况</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get deploy --all-namespaces</span><br><span class="line">NAMESPACE     NAME                   DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kube-system   heapster               1         1         1            1           41m</span><br><span class="line">kube-system   kube-dns               1         1         1            1           48m</span><br><span class="line">kube-system   kubernetes-dashboard   1         1         1            1           43m</span><br><span class="line">kube-system   monitoring-grafana     1         1         1            1           41m</span><br><span class="line">kube-system   monitoring-influxdb    1         1         1            1           41m</span><br></pre></td></tr></table></figure><ul><li>在k8s-master1、k8s-master2、k8s-master3任意节点上把kubernetes-dashboard、kube-dns、 scale up成replicas=3，保证各个master节点上都有运行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl scale --replicas=3 -n kube-system deployment/kube-dns</span><br><span class="line">$ kubectl get pods --all-namespaces -o wide| grep kube-dns</span><br><span class="line"></span><br><span class="line">$ kubectl scale --replicas=3 -n kube-system deployment/kubernetes-dashboard</span><br><span class="line">$ kubectl get pods --all-namespaces -o wide| grep kubernetes-dashboard</span><br><span class="line"></span><br><span class="line">$ kubectl scale --replicas=3 -n kube-system deployment/heapster</span><br><span class="line">$ kubectl get pods --all-namespaces -o wide| grep heapster</span><br><span class="line"></span><br><span class="line">$ kubectl scale --replicas=3 -n kube-system deployment/monitoring-grafana</span><br><span class="line">$ kubectl get pods --all-namespaces -o wide| grep monitoring-grafana</span><br><span class="line"></span><br><span class="line">$ kubectl scale --replicas=3 -n kube-system deployment/monitoring-influxdb</span><br><span class="line">$ kubectl get pods --all-namespaces -o wide| grep monitoring-influxdb</span><br></pre></td></tr></table></figure><hr><p><a href="#目录">返回目录</a></p><h4 id="keepalived安装配置"><a href="#keepalived安装配置" class="headerlink" title="keepalived安装配置"></a>keepalived安装配置</h4><ul><li>在k8s-master、k8s-master2、k8s-master3上安装keepalived</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y keepalived</span><br><span class="line"></span><br><span class="line">$ systemctl enable keepalived &amp;&amp; systemctl restart keepalived</span><br></pre></td></tr></table></figure><ul><li>在k8s-master1、k8s-master2、k8s-master3上备份keepalived配置文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mv /etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf.bak</span><br></pre></td></tr></table></figure><ul><li>在k8s-master1、k8s-master2、k8s-master3上设置apiserver监控脚本，当apiserver检测失败的时候关闭keepalived服务，转移虚拟IP地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/keepalived/check_apiserver.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">err=0</span><br><span class="line">for k in $( seq 1 10 )</span><br><span class="line">do</span><br><span class="line">    check_code=$(ps -ef|grep kube-apiserver | wc -l)</span><br><span class="line">    if [ &quot;$check_code&quot; = &quot;1&quot; ]; then</span><br><span class="line">        err=$(expr $err + 1)</span><br><span class="line">        sleep 5</span><br><span class="line">        continue</span><br><span class="line">    else</span><br><span class="line">        err=0</span><br><span class="line">        break</span><br><span class="line">    fi</span><br><span class="line">done</span><br><span class="line">if [ &quot;$err&quot; != &quot;0&quot; ]; then</span><br><span class="line">    echo &quot;systemctl stop keepalived&quot;</span><br><span class="line">    /usr/bin/systemctl stop keepalived</span><br><span class="line">    exit 1</span><br><span class="line">else</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">chmod a+x /etc/keepalived/check_apiserver.sh</span><br></pre></td></tr></table></figure><ul><li>在k8s-master1、k8s-master2、k8s-master3上查看接口名字</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ip a | grep 192.168.60</span><br></pre></td></tr></table></figure><ul><li>在k8s-master1、k8s-master2、k8s-master3上设置keepalived，参数说明如下：</li><li>state ${STATE}：为MASTER或者BACKUP，只能有一个MASTER</li><li>interface ${INTERFACE_NAME}：为本机的需要绑定的接口名字（通过上边的<code>ip a</code>命令查看）</li><li>mcast_src_ip ${HOST_IP}：为本机的IP地址</li><li>priority ${PRIORITY}：为优先级，例如102、101、100，优先级越高越容易选择为MASTER，优先级不能一样</li><li>${VIRTUAL_IP}：为虚拟的IP地址，这里设置为192.168.60.80</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/keepalived/keepalived.conf</span><br><span class="line">! Configuration File for keepalived</span><br><span class="line">global_defs &#123;</span><br><span class="line">    router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script chk_apiserver &#123;</span><br><span class="line">    script &quot;/etc/keepalived/check_apiserver.sh&quot;</span><br><span class="line">    interval 2</span><br><span class="line">    weight -5</span><br><span class="line">    fall 3  </span><br><span class="line">    rise 2</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state $&#123;STATE&#125;</span><br><span class="line">    interface $&#123;INTERFACE_NAME&#125;</span><br><span class="line">    mcast_src_ip $&#123;HOST_IP&#125;</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority $&#123;PRIORITY&#125;</span><br><span class="line">    advert_int 2</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 4be37dc3b4c90194d1600c483e10ad1d</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        $&#123;VIRTUAL_IP&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">       chk_apiserver</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在k8s-master1、k8s-master2、k8s-master3上重启keepalived服务，检测虚拟IP地址是否生效</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl restart keepalived</span><br><span class="line">$ ping 192.168.60.80</span><br></pre></td></tr></table></figure><hr><p><a href="#目录">返回目录</a></p><h4 id="nginx负载均衡配置"><a href="#nginx负载均衡配置" class="headerlink" title="nginx负载均衡配置"></a>nginx负载均衡配置</h4><ul><li>在k8s-master1、k8s-master2、k8s-master3上修改nginx-default.conf设置，${HOST_IP}对应k8s-master1、k8s-master2、k8s-master3的地址。通过nginx把访问apiserver的6443端口负载均衡到8433端口上</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ vi /root/kubeadm-ha/nginx-default.conf</span><br><span class="line">stream &#123;</span><br><span class="line">    upstream apiserver &#123;</span><br><span class="line">        server $&#123;HOST_IP&#125;:6443 weight=5 max_fails=3 fail_timeout=30s;</span><br><span class="line">        server $&#123;HOST_IP&#125;:6443 weight=5 max_fails=3 fail_timeout=30s;</span><br><span class="line">        server $&#123;HOST_IP&#125;:6443 weight=5 max_fails=3 fail_timeout=30s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8443;</span><br><span class="line">        proxy_connect_timeout 1s;</span><br><span class="line">        proxy_timeout 3s;</span><br><span class="line">        proxy_pass apiserver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在k8s-master1、k8s-master2、k8s-master3上启动nginx容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 8443:8443 \</span><br><span class="line">--name nginx-lb \</span><br><span class="line">--restart always \</span><br><span class="line">-v /root/kubeadm-ha/nginx-default.conf:/etc/nginx/nginx.conf \</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure><ul><li>在k8s-master1、k8s-master2、k8s-master3上检测keepalived服务的虚拟IP地址指向</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L 192.168.60.80:8443 | wc -l</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100    14    0    14    0     0  18324      0 --:--:-- --:--:-- --:--:-- 14000</span><br><span class="line">1</span><br></pre></td></tr></table></figure><ul><li>业务恢复后务必重启keepalived，否则keepalived会处于关闭状态</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl restart keepalived</span><br></pre></td></tr></table></figure><ul><li>在k8s-master1、k8s-master2、k8s-master3上查看keeplived日志，有以下输出表示当前虚拟IP地址绑定的主机</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl status keepalived -l</span><br><span class="line">VRRP_Instance(VI_1) Sending gratuitous ARPs on ens160 for 192.168.60.80</span><br></pre></td></tr></table></figure><hr><p><a href="#目录">返回目录</a></p><h4 id="kube-proxy配置"><a href="#kube-proxy配置" class="headerlink" title="kube-proxy配置"></a>kube-proxy配置</h4><ul><li>在k8s-master1上设置kube-proxy使用keepalived的虚拟IP地址，避免k8s-master1异常的时候所有节点的kube-proxy连接不上</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get -n kube-system configmap</span><br><span class="line">NAME                                 DATA      AGE</span><br><span class="line">extension-apiserver-authentication   6         4h</span><br><span class="line">kube-flannel-cfg                     2         4h</span><br><span class="line">kube-proxy                           1         4h</span><br></pre></td></tr></table></figure><ul><li>在k8s-master1上修改configmap/kube-proxy的server指向keepalived的虚拟IP地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl edit -n kube-system configmap/kube-proxy</span><br><span class="line">        server: https://192.168.60.80:8443</span><br></pre></td></tr></table></figure><ul><li>在k8s-master1上查看configmap/kube-proxy设置情况</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get -n kube-system configmap/kube-proxy -o yaml</span><br></pre></td></tr></table></figure><ul><li>在k8s-master1上删除所有kube-proxy的pod，让proxy重建</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods --all-namespaces -o wide | grep proxy</span><br></pre></td></tr></table></figure><ul><li>在k8s-master1、k8s-master2、k8s-master3上重启docker kubelet keepalived服务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl restart docker kubelet keepalived</span><br></pre></td></tr></table></figure><hr><p><a href="#目录">返回目录</a></p><h4 id="验证master集群高可用"><a href="#验证master集群高可用" class="headerlink" title="验证master集群高可用"></a>验证master集群高可用</h4><ul><li>在k8s-master1上检查各个节点pod的启动状态，每个上都成功启动heapster、kube-apiserver、kube-controller-manager、kube-dns、kube-flannel、kube-proxy、kube-scheduler、kubernetes-dashboard、monitoring-grafana、monitoring-influxdb。并且所有pod都处于Running状态表示正常</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods --all-namespaces -o wide | grep k8s-master1</span><br><span class="line"></span><br><span class="line">$ kubectl get pods --all-namespaces -o wide | grep k8s-master2</span><br><span class="line"></span><br><span class="line">$ kubectl get pods --all-namespaces -o wide | grep k8s-master3</span><br></pre></td></tr></table></figure><hr><p><a href="#目录">返回目录</a></p><h3 id="node节点加入高可用集群设置"><a href="#node节点加入高可用集群设置" class="headerlink" title="node节点加入高可用集群设置"></a>node节点加入高可用集群设置</h3><h4 id="kubeadm加入高可用集群"><a href="#kubeadm加入高可用集群" class="headerlink" title="kubeadm加入高可用集群"></a>kubeadm加入高可用集群</h4><ul><li>在k8s-master1上禁止在所有master节点上发布应用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl patch node k8s-master1 -p &apos;&#123;&quot;spec&quot;:&#123;&quot;unschedulable&quot;:true&#125;&#125;&apos;</span><br><span class="line"></span><br><span class="line">$ kubectl patch node k8s-master2 -p &apos;&#123;&quot;spec&quot;:&#123;&quot;unschedulable&quot;:true&#125;&#125;&apos;</span><br><span class="line"></span><br><span class="line">$ kubectl patch node k8s-master3 -p &apos;&#123;&quot;spec&quot;:&#123;&quot;unschedulable&quot;:true&#125;&#125;&apos;</span><br></pre></td></tr></table></figure><ul><li>在k8s-master1上查看集群的token</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm token list</span><br><span class="line">TOKEN           TTL         EXPIRES   USAGES                   DESCRIPTION</span><br><span class="line">xxxxxx.yyyyyy   &lt;forever&gt;   &lt;never&gt;   authentication,signing   The default bootstrap token generated by &apos;kubeadm init&apos;</span><br></pre></td></tr></table></figure><ul><li>在k8s-node1 ~ k8s-node8上，${TOKEN}为k8s-master1上显示的token，${VIRTUAL_IP}为keepalived的虚拟IP地址192.168.60.80</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm join --token $&#123;TOKEN&#125; $&#123;VIRTUAL_IP&#125;:8443</span><br></pre></td></tr></table></figure><hr><p><a href="#目录">返回目录</a></p><h4 id="部署应用验证集群"><a href="#部署应用验证集群" class="headerlink" title="部署应用验证集群"></a>部署应用验证集群</h4><ul><li>在k8s-node1 ~ k8s-node8上查看kubelet状态，kubelet状态为active (running)表示kubelet服务正常启动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl status kubelet</span><br><span class="line">● kubelet.service - kubelet: The Kubernetes Node Agent</span><br><span class="line">   Loaded: loaded (/etc/systemd/system/kubelet.service; enabled; vendor preset: disabled)</span><br><span class="line">  Drop-In: /etc/systemd/system/kubelet.service.d</span><br><span class="line">           └─10-kubeadm.conf</span><br><span class="line">   Active: active (running) since Tue 2017-06-27 16:23:43 CST; 1 day 18h ago</span><br><span class="line">     Docs: http://kubernetes.io/docs/</span><br><span class="line"> Main PID: 1146 (kubelet)</span><br><span class="line">   Memory: 204.9M</span><br><span class="line">   CGroup: /system.slice/kubelet.service</span><br><span class="line">           ├─ 1146 /usr/bin/kubelet --kubeconfig=/etc/kubernetes/kubelet.conf --require...</span><br><span class="line">           ├─ 2553 journalctl -k -f</span><br><span class="line">           ├─ 4988 /usr/sbin/glusterfs --log-level=ERROR --log-file=/var/lib/kubelet/pl...</span><br><span class="line">           └─14720 /usr/sbin/glusterfs --log-level=ERROR --log-file=/var/lib/kubelet/pl...</span><br></pre></td></tr></table></figure><ul><li>在k8s-master1上检查各个节点状态，发现所有k8s-nodes节点成功加入</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes -o wide</span><br><span class="line">NAME          STATUS                     AGE       VERSION</span><br><span class="line">k8s-master1   Ready,SchedulingDisabled   5h        v1.7.0</span><br><span class="line">k8s-master2   Ready,SchedulingDisabled   4h        v1.7.0</span><br><span class="line">k8s-master3   Ready,SchedulingDisabled   4h        v1.7.0</span><br><span class="line">k8s-node1     Ready                      6m        v1.7.0</span><br><span class="line">k8s-node2     Ready                      4m        v1.7.0</span><br><span class="line">k8s-node3     Ready                      4m        v1.7.0</span><br><span class="line">k8s-node4     Ready                      3m        v1.7.0</span><br><span class="line">k8s-node5     Ready                      3m        v1.7.0</span><br><span class="line">k8s-node6     Ready                      3m        v1.7.0</span><br><span class="line">k8s-node7     Ready                      3m        v1.7.0</span><br><span class="line">k8s-node8     Ready                      3m        v1.7.0</span><br></pre></td></tr></table></figure><ul><li>在k8s-master1上测试部署nginx服务，nginx服务成功部署到k8s-node5上</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl run nginx --image=nginx --port=80</span><br><span class="line">deployment &quot;nginx&quot; created</span><br><span class="line"></span><br><span class="line">$ kubectl get pod -o wide -l=run=nginx</span><br><span class="line">NAME                     READY     STATUS    RESTARTS   AGE       IP           NODE</span><br><span class="line">nginx-2662403697-pbmwt   1/1       Running   0          5m        10.244.7.6   k8s-node5</span><br></pre></td></tr></table></figure><ul><li>在k8s-master1让nginx服务外部可见</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl expose deployment nginx --port=80 --target-port=80 --type=NodePort</span><br><span class="line">service &quot;nginx&quot; exposed</span><br><span class="line"></span><br><span class="line">$ kubectl get svc -l=run=nginx</span><br><span class="line">NAME      CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">nginx     10.105.151.69   &lt;nodes&gt;       80:31639/TCP   43s</span><br><span class="line"></span><br><span class="line">$ curl k8s-master2:31639</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        width: 35em;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">        font-family: Tahoma, Verdana, Arial, sans-serif;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="至此，kubernetes高可用集群成功部署。"><a href="#至此，kubernetes高可用集群成功部署。" class="headerlink" title="至此，kubernetes高可用集群成功部署。"></a>至此，kubernetes高可用集群成功部署。</h2><p><a href="#目录">返回目录</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/img/Kubernetes.png&quot; alt=&quot;k8s logo&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>synchronized和ReentrantLock的区别</title>
    <link href="http://lioncruise.github.io/2017/07/25/synchronized-vs-reentrantlock/"/>
    <id>http://lioncruise.github.io/2017/07/25/synchronized-vs-reentrantlock/</id>
    <published>2017-07-25T15:02:18.000Z</published>
    <updated>2018-01-14T12:54:34.297Z</updated>
    
    <content type="html"><![CDATA[<p>之前很多同学面试Java开发岗位被问到了synchronized和ReentrantLock的区别这个问题。带着好奇心，我就去查了一下，没想到在细节上居然有这么大的区别。</p><a id="more"></a><p>除了synchronized关键字之外，我们还可以使用java.util.concurrent中的重入锁（ReentrantLock）来实现同步，在基本用法上，他们很相似，都具备一样的 <strong>线程重入</strong> 的特性。在代码写法上有点区别：ReentrantLock表现为API层面的互斥锁（lock()和unlock()方法配合try catch语句块来完成），synchronized表现为原生语法层面的互斥锁。不过，ReentrantLock相比synchronized增加了一些高级功能。主要有一下3项：等待可中断、可实现公平锁、锁可以绑定多个条件。</p><ul><li>等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。</li><li>公平锁 是指多个线程在等待同一个锁时，必须按照申请锁的时间来一次获得锁，而非公平锁不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁时非公平的，ReentrantLock默认情况也是非公平的，但也可以通过代布尔值的函数要求使用公平锁。</li><li>锁绑定是指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件，如果要和多于一个条件关联的时候，就不得不额外添加一个锁，而ReentrantLock则无需这样做，只需要多次调用newCondition()方法即可。</li></ul><p>JDK 1.6发布之后，synchronized和ReentrantLock的性能基本上完全持平，提倡在synchronized能实现需求的情况下，优先考虑使用synchronized。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前很多同学面试Java开发岗位被问到了synchronized和ReentrantLock的区别这个问题。带着好奇心，我就去查了一下，没想到在细节上居然有这么大的区别。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://lioncruise.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://lioncruise.github.io/tags/Java/"/>
    
      <category term="Java并发编程" scheme="http://lioncruise.github.io/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java锁的优化思路</title>
    <link href="http://lioncruise.github.io/2017/07/04/java-lock-optimization/"/>
    <id>http://lioncruise.github.io/2017/07/04/java-lock-optimization/</id>
    <published>2017-07-04T14:38:23.000Z</published>
    <updated>2018-01-14T12:55:20.661Z</updated>
    
    <content type="html"><![CDATA[<p>为了在线程之间更加高效地共享数据，解决竞争问题，从而提高效率。针对不同应用场景，提出了以下几种锁优化的思路。</p><a id="more"></a><h2 id="自旋锁、自适应自旋"><a href="#自旋锁、自适应自旋" class="headerlink" title="自旋锁、自适应自旋"></a>自旋锁、自适应自旋</h2><p>Java多线程中，互斥同步对性能影响最大的是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态完成，这给系统的并发性带来了很大的影响。</p><p>很多时候，共享数据的锁定状态只会持续很短一段时间，为了这段时间去挂起、恢复线程并不值得。为了让线程等待（并不是被挂起），我们只需要让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。</p><p>如果锁被占用的时间很短，用自旋锁自旋等待的效果就非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗资源，适得其反。</p><p>所以就有了 自适应自旋 ，根据程序运行和性能监控的信息，对自旋时间预测。</p><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>锁消除是指JVM即时编译器在运行时，一些代码要求同步，但是被检测到不可能存在共享数据竞争，然后就将锁消除。</p><h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>如果一系列连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体里面，那么即使没有线程竞争，频繁进行互斥同步操作也会导致不必要的性能损耗。因此就有了 锁粗化，增大锁的范围，减少加锁释放锁的次数。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>synchronized、ReentrantLock这样的互斥同步属于悲观并发控制。其涉及到用户态到内核态转换、维护锁计数器、检查是否有被阻塞的线程需要唤醒等操作，性能开销较大。</p><p>基于冲突检测的乐观并发控制。就是先进行操作，如果没有其他线程竞争共享数据，就成功了；否则失败，重试到成功为止。这种乐观并发控制的许多实现都不需要把线程挂起，因此这种同步操作称为 <strong>非阻塞同步</strong>。</p><p>乐观并发控制，需要 操作 和 冲突检测 这两个步骤具备 原子性。</p><p>CAS指令（compare and set）：比较并赋值。CAS指令执行时，当且仅当变量V符合旧预期值A时，CPU才用新值B更新V的值，否则就不执行更新。CAS指令的全部操作是一个原子操作。在JDK 1.5之后，Java程序中才能使用CAS操作。</p><p>CAS操作应该算是 乐观并发控制的一种实现。</p><p>CAS操作的逻辑漏洞。并发包提供了一个带有标记的原子引用类，可以通过控制变量的版本来保证CAS的正确性。</p><p>乐观锁在数据竞争频繁的情况下，会产生大量失败重试，从而极大降低性能。</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>锁偏向是一种针对加锁操作的优化手段。它的核心思想是：如果一个线程获得了锁，那么锁就进入偏向模式。当这个线程再次请求锁时，无须再做任何同步操作。这样就节省了大量有关锁申请的操作，从而提高了程序性能。因此，对于几乎没有锁竞争的场合，偏向锁有比较好的优化效果，因为连续多次极有可能是同一个线程请求相同的锁。而对于锁竞争比较激烈的场合，其效果不佳。因为在竞争激烈的场合，最有可能的情况是每次都是不同的线程来请求相同的锁。这样偏向模式会失效，因此还不如不启用偏向锁。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了在线程之间更加高效地共享数据，解决竞争问题，从而提高效率。针对不同应用场景，提出了以下几种锁优化的思路。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://lioncruise.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://lioncruise.github.io/tags/Java/"/>
    
      <category term="Java并发编程" scheme="http://lioncruise.github.io/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>浅谈并发事务</title>
    <link href="http://lioncruise.github.io/2017/05/20/concurrent-transaction/"/>
    <id>http://lioncruise.github.io/2017/05/20/concurrent-transaction/</id>
    <published>2017-05-20T08:42:43.000Z</published>
    <updated>2018-01-14T12:57:44.835Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发事务的问题"><a href="#并发事务的问题" class="headerlink" title="并发事务的问题"></a>并发事务的问题</h2><p>当同一个数据（对象）被并发事务访问的时候，会有什么问题？</p><p><img src="/img/并发事务访问同一个对象.png" alt=""></p><p>上面的场景可以理解为：同一个账户两笔转账并发发生会怎么样？假设X初始值为100，那么最终X会变为多少？</p><a id="more"></a><p><img src="/img/并发事务可能导致不同结果.png" alt=""></p><p>其原因在于X=X+1并不是一个原子操作，而是Read(X)和Write(X)这两个原子操作的集合。这就导致 同一个对象上的并发事务 可能因为原子操作的不同顺序而导致最终结果不同。</p><h2 id="并发事务的正确性"><a href="#并发事务的正确性" class="headerlink" title="并发事务的正确性"></a>并发事务的正确性</h2><p>如何判断一组 并发事务 正确执行？</p><p><strong>存在</strong>一个顺序，按照这个顺序依次<strong>串行执行</strong>这些事务，得到的结果与并行执行的结果相同。我们就说这个组并发事务是<strong>可串行化</strong>的。这也是判断一组并行事务是否正确执行的标准。如果一组并行事务的执行结果找不到任何一组串行执行的结果与其相同，那么可以说这组并发事务没有正确的执行。比如在上一节的情景中，如果2个并发事务的执行结果为102则正确执行，如果为101则没有正确执行。</p><h2 id="并发事务的4种隔离级别"><a href="#并发事务的4种隔离级别" class="headerlink" title="并发事务的4种隔离级别"></a>并发事务的4种隔离级别</h2><p>数据冲突引起的问题</p><ul><li>read uncommited data（读脏数据）：在T2提交之前，T1读了T2已经修改了的数据</li><li>unrepeatable reads（不可重复读）：在T2提交之前，T1写了T2已经读的数据。如果T2再次读同一个数据，那么将发现两次读取的值不同。因此叫做不可重复读。</li><li>overwrite uncommitted data（更新丢失）：在T2提交之前，T1重写了T2已经修改的数据。</li></ul><pre><code>|         | 读未提交（脏读） | 不可重复读 | 更新丢失   || :-----: | :-----------: | :-------: | :------: ||  序列化  | no            | no        | no       || 可重复读 | no            | no        | possible || 读已提交 | no            | possible  | possible || 读未提交 | possible      | possible  | possible |</code></pre><p>MySQL事务默认的隔离层级是可重复读，不会出现脏读和幻读现象，但是有可能会有一个事务的更新被另外一个事务的更新覆盖导致更新丢失的现象。</p><p>完全序列化大绝大多数情况下是没有必要的，因为很多并发事务并不会同时访问同一个对象（即没有数据竞争）。使用完全序列化这个隔离级别会极大降低并发的性能。</p><p>针对上面问题的举例：</p><p><img src="/img/并发事务问题举例1.jpg" alt=""></p><p><img src="/img/并发事务问题举例2.jpg" alt=""></p><h2 id="针对并发事务的解决方案"><a href="#针对并发事务的解决方案" class="headerlink" title="针对并发事务的解决方案"></a>针对并发事务的解决方案</h2><p>针对并发事务，主要是两大类解决方案。</p><h3 id="悲观并发控制"><a href="#悲观并发控制" class="headerlink" title="悲观并发控制"></a>悲观并发控制</h3><p>使用悲观并发控制的前提假设是：数据竞争可能经常出现，即并发事务可能经常访问同一个对象。</p><p>悲观并发控制的主要手段是 <strong>防止</strong>，即采用某种机制确保数据竞争不会出现。</p><p>如果一个事务T可能和正在运行的其他事务有冲突，那么就让这个T等待，一直等到有冲突的其他所有事务都完成为止，才开始执行事务T。</p><p>一般，悲观并发控制使用加锁协议来实现，对事务中的读写数据进行加锁，通常采用 <strong>两阶段加锁</strong>（2 Phase Locking，2PL）。</p><p>2PL:</p><ul><li>对每个访问的数据都要加锁之后才能访问</li><li>在事务开始的时候，对每个需要访问的数据加锁。如果不能加锁，就等待，直到加锁成功。加锁成功之后，执行事务内容。在事务提交之前，集中进行解锁。最后，事务提交。</li><li>有一个<strong>集中</strong>的加锁阶段和一个<strong>集中</strong>的解锁阶段，两阶段加锁由此得名。</li></ul><p><img src="/img/2PL.png" alt=""></p><p>如上图，使用2PL之后，两个会访问同一个对象的并发事务不会同一时刻执行。</p><p>悲观锁为什么一定要集中在事务开始和事务提交两个阶段呢？</p><p><img src="/img/锁为什么一定要两阶段.png" alt=""></p><p>上面这个图，在保证没有脏读和幻读的情况下，就会出现事务T2更新丢失的情况。</p><h3 id="悲观锁的实现"><a href="#悲观锁的实现" class="headerlink" title="悲观锁的实现"></a>悲观锁的实现</h3><ul><li>Shared lock(<strong>共享锁</strong>，S)：保护读操作</li><li>Exclusive lock(<strong>排它锁</strong>，X)：保护写操作</li></ul><p><img src="/img/共享锁排它锁比较.png" alt=""></p><p>一个对象被一个读锁占用，可以同时被另外一个读锁占用，但是不能被写锁占用。一个对象被一个写锁占用，不能被其他的读锁或写锁占用。</p><p>数据库锁的实现粒度也是不同的。锁的对象可以是表、行（记录）、索引等。</p><p>Intent lock（<strong>意向锁</strong>）<strong>是为了提高封锁子系统的效率</strong>：</p><ul><li>意向读锁 IS(a)：将对a下面更细粒度的数据元素进行读</li><li>意向写锁 IX(a)：将对a下面更细粒度的数据元素进行写</li></ul><p>为了得到S、IS，所有祖先必须为IS或IX。为了得到X、IX，所有祖先必须为IX（不能为IS，如果祖先是IS，那么别的事务就可以对祖先申请S锁，这与那个子孙对象是X锁显然是相矛盾的）。</p><h3 id="乐观并发控制"><a href="#乐观并发控制" class="headerlink" title="乐观并发控制"></a>乐观并发控制</h3><p>使用乐观并发控制的前提是：数据竞争很少，即并发事务很少会访问到同一个对象上。</p><p>乐观并发控制的主要手段是 <strong>检查</strong>。具体过程为：允许所有的事务都直接执行。但是事务不直接修改数据，而是将修改保留到这个事务的<strong>私有工作区</strong>。当事务结束时，检查这些修改是否有数据竞争。如果没有冲突（即没有其他并发事务访问到同一个对象），检查通过，将私有工作区的修改复制到数据库公共数据中，成功结束；如果有竞争，清空私有工作区，重试事务。</p><p>MVCC（Multiversion concurrency control）是一种非常常见的乐观并发控制的实现方式，以加时间戳验证的方式实现。</p><p><img src="/img/MVCC.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;并发事务的问题&quot;&gt;&lt;a href=&quot;#并发事务的问题&quot; class=&quot;headerlink&quot; title=&quot;并发事务的问题&quot;&gt;&lt;/a&gt;并发事务的问题&lt;/h2&gt;&lt;p&gt;当同一个数据（对象）被并发事务访问的时候，会有什么问题？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/并发事务访问同一个对象.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面的场景可以理解为：同一个账户两笔转账并发发生会怎么样？假设X初始值为100，那么最终X会变为多少？&lt;/p&gt;
    
    </summary>
    
      <category term="分布式系统" scheme="http://lioncruise.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式系统" scheme="http://lioncruise.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="事务" scheme="http://lioncruise.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="数据库" scheme="http://lioncruise.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>《大数据系统与数据分析》之存储</title>
    <link href="http://lioncruise.github.io/2017/05/03/big-data-storage/"/>
    <id>http://lioncruise.github.io/2017/05/03/big-data-storage/</id>
    <published>2017-05-03T08:02:20.000Z</published>
    <updated>2018-01-14T12:53:22.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><p>分布式系统由网络将不同的机器连接起来。</p><p>类型：</p><ul><li>C/S</li><li>P2P（没有中心节点，整个系统功能完全是分布式完成的）</li></ul><p>CAP理论：</p><ul><li>多份数据的 一致性</li><li>系统的 可用性</li><li>容忍网络断开</li></ul><p>CAP三者不可兼得。</p><a id="more"></a><h2 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h2><p>GFS</p><ul><li>C/C++实现</li><li>Google MapReduce的基础</li></ul><p>HDFS</p><ul><li>GFS的开源实现</li><li>基于Java</li><li>应用层的文件系统（下面说明应用层文件系统和普通文件系统的不同）</li></ul><p>普通文件系统，比如POSIX文件系统，本来就是OS内核的一部分，其对外提供系统调用。</p><p>而HDFS，要对其上内容进行操作，必须连接HDFS client，HDFS client完全是一个用户程序，其底层调用了普通文件系统提供的系统调用。</p><p>GFS的设计目标：</p><ul><li>大块数据的顺序读</li><li>并行追加（append）</li><li>不支持修改（overwrite）操作，因此 一致性 的实现可以大大简化</li></ul><p>GFS/HDFS系统架构</p><p><img src="/img/NameNode-DataNode.png" alt="GFS/HDFS系统架构"></p><ul><li>大文件切分成定长的数据块（默认64MB大小的数据块）</li><li>每个数据块独立地分布存储在DataNode上</li><li>默认每个数据块存储3份，在3个不同的DataNode上（提高可用性）</li><li>很好的顺序读性能</li></ul><h2 id="分布式存储（KV型）"><a href="#分布式存储（KV型）" class="headerlink" title="分布式存储（KV型）"></a>分布式存储（KV型）</h2><p>NoSQL大部分是又互联网公司研发的，目标是支持本公司的某类重要的应用。关系型数据库不能满足特定的需求。</p><p>NoSQL往往是针对目标应用开发，简化了许多关系型数据库的功能，提高了系统性能、伸缩性等。不支持（完全的）SQL，不支持（完全的）ACID。</p><p>KV 型存储</p><p>KV 数据库通常是PUT和GET这两个操作。著名的KV型NoSQL有以下几个：</p><p>Amazon Dynamo</p><p>支持Amazon电商平台上运行的大量服务。比如，best sellers lists、购物车、session 管理等。</p><p><img src="/img/Dynamo.png" alt="Dynamo系统结构"></p><p>关键技术：一致性Hash算法。</p><p>备份：数据存储3份。</p><p>节点负载的问题：用 虚拟节点 解决。</p><p>Quorum机制（Quorum:翻译为法定人数）：如果有N个副本，要求写的时候保证至少写了W个副本，要 求读的时候至少从R个副本读了数据，满足R+W&gt;N，那么一定读到了最新的数据。R比较小，那么读的效率就越高；W比较小，那么写的效率就越高。</p><p><img src="/img/Dynamo写.png" alt="Dynamo PUT操作"></p><p><img src="/img/Dynamo读.png" alt="Dynamo GET操作"></p><p>Quorum机制是一种 弱一致性 的解决方案。Put操作并没有等待所有N个节点全部写完成，可以提高写效率，增加系统性能。系统总会 <strong>最终</strong> 保证每个KV的N个副本都写成功，最终一致，但是不保证短时间内达到一致，最终可能需要很长的时间才能达到一致。</p><p>互联网应用，因为关系到用户体验，很多时候要更加注重 可用性（Availability）。</p><p>Google Bigtable/Apache HBase</p><p><img src="/img/BigTable结构.png" alt="BigTable结构"></p><ul><li>Key = row key + column family + column key</li><li>所有row key是按顺序存储的</li><li>其中column又有column family前缀。Column family是需要事先声明的，种类有限(例如~10或~100)，而column key可以有很多。</li><li>具体存储时，每个column family将分开存储（类似于列式数据库，见下图）</li></ul><p><img src="/img/BigTable的存储结构.png" alt="BigTable的存储结构"></p><p>上图中的 contents 和 anchor 是 column family，cnnsi.com和my.look.ca是anchor这个column family下的column key。上图省略了timestamp。</p><p>BigTable/HBase 是基于 分布式文件系统 GFS/HDFS 的，分布式文件系统自动给其上NoSQL备份了3份副本。</p><p>Bigtable / Hbase 操作：</p><ul><li>Get：给定row key, column family, column key，读取value</li><li>Put：给定row key, column family, column key，创建或更新value</li><li>Scan：给定一个范围，读取这个范围内所有row key的value（Row key是排序存储的）</li><li>Delete：删除一个指定的value</li></ul><p>HBase的实时性还可以，Hive的实时性非常差。</p><p>HBase最常见的应用场景就是采集网页数据的存储。由于是KV结构，后来扩展到存 日志 也可以。</p><p>HBase还是算作是OLTP的NoSQL。</p><p>日志（Log）的作用：排错、Crash recovery。</p><p>分布式协同：ZooKeeper</p><h2 id="文档存储系统"><a href="#文档存储系统" class="headerlink" title="文档存储系统"></a>文档存储系统</h2><p>JSON：一种轻量级的数据交换存储格式。</p><p>Google Protocol Buffers：Google退出的一种轻便高效的结构化数据存储传输格式。</p><p>JSON vs. XML：XML没有JSON轻量级，标签很重</p><p>Apache Thrift：实现多语言的相互RPC调用</p><p>mongoDB：</p><ul><li>JSON是基本数据类型，存储为BSON二进制表示</li><li>名词<ul><li>Database ~ 关系型中的数据库概念</li><li>Collection ~ 关系型中的table概念</li><li>Document ~ 关系型中的记录概念</li></ul></li><li>一个database包含多个collections， 每个collection包含多个documents。每个document的大小小于16MB</li></ul><p>mongoDB 也支持简单的类似SQL的CRUD、聚合等操作，但是不支持join这种操作。</p><p>mongoDB集群</p><ul><li>数据分片成多个shard</li><li>每个shard有多个副本</li></ul><h2 id="图存储系统"><a href="#图存储系统" class="headerlink" title="图存储系统"></a>图存储系统</h2><p>社交网络、地铁地图等的存储。</p><p>图数据存储系统</p><ul><li>存储图的顶点和边</li><li>提供顶点和边的查询</li></ul><p>Neo4j</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;分布式系统&quot;&gt;&lt;a href=&quot;#分布式系统&quot; class=&quot;headerlink&quot; title=&quot;分布式系统&quot;&gt;&lt;/a&gt;分布式系统&lt;/h2&gt;&lt;p&gt;分布式系统由网络将不同的机器连接起来。&lt;/p&gt;
&lt;p&gt;类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C/S&lt;/li&gt;
&lt;li&gt;P2P（没有中心节点，整个系统功能完全是分布式完成的）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CAP理论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多份数据的 一致性&lt;/li&gt;
&lt;li&gt;系统的 可用性&lt;/li&gt;
&lt;li&gt;容忍网络断开&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CAP三者不可兼得。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式系统" scheme="http://lioncruise.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式系统" scheme="http://lioncruise.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="分布式存储" scheme="http://lioncruise.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>《大数据系统与数据分析》之大数据计算</title>
    <link href="http://lioncruise.github.io/2017/05/01/big-data-computation/"/>
    <id>http://lioncruise.github.io/2017/05/01/big-data-computation/</id>
    <published>2017-05-01T07:06:57.000Z</published>
    <updated>2018-01-14T12:43:36.374Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>MapReduce 是一个编程模型。</p><p>并行分布式程序设计非常不容易，涉及到很多方面：</p><ul><li>多线程编程</li><li>socket编程</li><li>job的调度、协同、worker之间的负载均衡</li><li>节点的容错</li><li>分布式系统的debug比较困难</li></ul><p>MapReduce的整体思路就是：让 程序员 写 串行程序，并行分布式计算平台提供一些接口（比如Map、Reduce），并将其并行分布式地执行。</p><a id="more"></a><p>MR计算平台的作用就是：</p><ul><li>简化并行编程（编程时不需要思考并行的问题）</li><li>调试时只需要保证串行执行正确即可</li></ul><p>MR数据模型：</p><ul><li>数据由一条条记录构成</li><li>记录之间是无序的</li><li>每条记录有一个key，和一个value</li><li>key：可以不唯一</li><li>key和value的具体类型和内部结构由程序员决定，系统基本上把它们看作黑匣</li></ul><p>map-shuffle-reduce</p><p>word count 在mapper里面，程序员只要写统计 大文件 每行的每个词出现的频率即可，MR计算平台会自动地去map（将HDFS文件块输入到相应的TaskTracker）。shuffle起一个group by的作用，将map输出的结果相同的key的放到一起。然后在reducer里面，程序员只需要写将相同的key出现的次数相加即可，MR计算平台会自动地将上一步shuffle归并的结果（将相同key的<key，count>放一起），然后自动将这些分配到多个reduce的TaskTracker去做reduce操作。最后得到统计结果。</key，count></p><p>程序员只</p><p><img src="/img/wordcount.png" alt="word count"></p><p><img src="/img/MR和SQL比较.png" alt="MR和SQL的比较"></p><p>MapReduce/Hadoop系统架构</p><p><img src="/img/MapReduce架构.png" alt="MapReduce架构"></p><p>MR运行是基于HDFS的，用HDFS上读数据块（split）。</p><p>MR运行：提交作业（Job），包括Map函数、Reduce函数(Jar)、配置信息(例如，几个Mappers，几个 Reducers)、输入路径、输出路径等。</p><p><img src="/img/MR运行.jpeg" alt="MapReduce运行"></p><p>MR容错：</p><ol><li>心跳机制：TaskTracker定期发送，向JobTracker汇报进度</li><li>JobTracker可以及时发现不响应的机器或速度非常慢的机器。这些异常机器被称作Stragglers</li><li>一旦发现Straggler，JobTracker就将它需要做的工作分配给另一个worker</li><li>Straggler是Mapper，将所对应的splits（HDFS文件块）分配给其它的Mapper</li><li>Stragger是Reducer，在另一个TaskTracker执行这个Reducer</li></ol><h2 id="MapReduce-SQL"><a href="#MapReduce-SQL" class="headerlink" title="MapReduce+SQL"></a>MapReduce+SQL</h2><p>MapReduce 提供了一个并行分布式应用编写的 <strong>平台</strong> ，大大简化了并行分布式编程。</p><ul><li>程序员开发串行的 Map 和 Reduce 函数</li><li>在串行的环境开发和调试</li><li>MR计算平台可以在成百上千个机器节点上并发执行MR程序，从而实现对大规模数据的处理</li></ul><p>MapReduce+SQL系统在MR计算平台上增加了一层类似SQL的支持，方便一些查询分析操作。这类系统包括：</p><ul><li>Facebook Hive</li><li>Yahoo Pig</li><li>Microsoft Scope</li></ul><p>Hive是目前被最广泛使用的MapReduce+SQL系统。</p><p>Hive的作用：</p><ul><li>管理和处理结构化数据</li><li>在Hadoop基础上实现</li><li>提供类似SQL的HQL语言</li></ul><p><img src="/img/MR运行.jpeg" alt="Hive系统"></p><ul><li>数据存储在HDFS上。HDFS目录：<code>/usr/hive/warehouse/</code></li><li>Table：一个单独的HDFS目录，<code>/user/hive/warehouse/表名</code></li><li>Table可以进一步划分为Partition</li><li>Partition可以进一步划分为Bucket</li></ul><p>HQL，Hive会将其转换成MR程序执行。</p><p>MetaStore</p><ul><li>存储表的定义信息等</li><li>默认在本地<code>${HIVE_HOME}/metastore_db</code>中，也可以配置存储在数据库RDBMS中</li></ul><p>Hive CLI（命令行客户端，可以执行各种HQL命令）</p><p>Hive数据模型：关系型表 + 扩展。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE status_updates( </span><br><span class="line">userid int,status string </span><br><span class="line">)</span><br><span class="line">PARTITIONED BY (ds string, hr int)STORED AS SEQUENCEFILE;</span><br></pre></td></tr></table></figure><p>ds是partition key, hr是bucket key 它们都不包括在table schema中。</p><p>Hive在 关系型表 上的扩展</p><ul><li>关系型表的列只能是 原子类型，而Hive表的列可以是更加复杂的数据类型（比如ARRAY、MAP、STRUCT）</li><li>Hive可以直接读取已有的外部数据（比如，从Hive里读MySQL的数据，但是没有将MySQL中的数据导入到Hive里面）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t1(</span><br><span class="line">st string,</span><br><span class="line">fl float,</span><br><span class="line">a array&lt;int&gt;,</span><br><span class="line">m map&lt;string, string&gt;,</span><br><span class="line">n array&lt;map&lt;string, struct&lt;p1:int, p2:int&gt;&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Partition 使用举例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT OVERWRITE TABLEstatus_updates PARTITION(ds=&apos;2009-01-01&apos;, hr=12) </span><br><span class="line">SELECT * FROM t;</span><br></pre></td></tr></table></figure><p>然后，会在如下的子目录中，存储select的输出：</p><p><code>/user/hive/warehouse/status_updates/ds=2009-01-01/hr=12</code></p><p>ds是 partition key，所以 Hive 只使用对应的子目录中的数据。</p><p>Hive select 支持的操作：filter、aggregation（聚合）、简单的join。</p><p>Hive 主要的用户就是统计分析操作。Facebook 在生产环境中每天要跑上万个Hive Job。Hive 使 Hadoop 一些和SQL相关的操作化简了，非程序员也完全可以使用Hive。大多数的Hadoop Job都是Hive Job。跑这些 Hive Job 大多时候是用来生成相关报表，支持决策的。</p><h2 id="内存计算"><a href="#内存计算" class="headerlink" title="内存计算"></a>内存计算</h2><p>随着内存容量的越来越大，越来越大的数据集可以完全存在在内存中。</p><p>内存处理的优点：去除了硬盘IO的开销，极大地提高的速度。</p><h3 id="内存KV数据库"><a href="#内存KV数据库" class="headerlink" title="内存KV数据库"></a>内存KV数据库</h3><p>Memcached：只提供简单的KV结构，内存利用率高一些</p><p>Redis：提供更加丰富的数据类型，RDB快照和AOF日志功能保证数据的可靠性。Redis是单线程的，一个Redis实例只能利用一个核。</p><p>Facebook 的 MySQL + Memcached 结构。</p><p>大多数场景，数据库90%+是读操作，写操作非常少，使得缓存、读写分离这些机制得以应用。</p><p>访问数据先看缓存中有没有，有的话访问缓存直接拿数据，否则访问MySQL中记录，然后将其放到Memcached缓存中，如果MySQL中数据变化，同步commit log将相应的缓存失效。使用LRU作缓存替换策略。</p><p>Memcached 更像是一种纯粹的缓存，而Redis则更像是一种基于内存的数据库。</p><h3 id="内存MapReduce"><a href="#内存MapReduce" class="headerlink" title="内存MapReduce"></a>内存MapReduce</h3><p>Spark：面向大数据分析的内存系统</p><ul><li>SparkSQL</li><li>SparkStreaming</li><li>MLlib</li><li>GraphX</li></ul><p>可以从HDFS中读数据，但是运算过程中 数据放在内存中（而不是像Hadoop MapReduce那样将中间的计算结果落到磁盘，然后又从磁盘读入）。内存计算的目标是低延迟的分析操作。</p><p>Hadoop MapReduce 的问题：通过HDFS进行作用间的数据共享，导致计算的中间结果都要落地到硬盘，代价太高。</p><p><img src="/img/MapReduce的问题.png" alt="MapReduce的问题"></p><p>Spark的思路：</p><ul><li>内存容量越来越大</li><li>将数据放入多台机器的内存</li><li>避免计算中间结果在HDFS上读写的开销</li></ul><p><img src="/img/Spark思路.png" alt="Spark的思路"></p><p>RDD（Resilientt Distributed Data sets, 弹性分布式数据集）</p><ul><li>一个数据集</li><li>只读，整个数据集创建之后不能修改</li><li>通常进行整个数据集的运算</li></ul><p>RDD优点：</p><ul><li>因为只读，并发控制变简单了</li><li>并不需要把RDD存储在stable storage（硬盘）上</li></ul><p>RDD运算：</p><ul><li>Transformation<ul><li>输入时RDD</li><li>输出也是RDD</li><li>仅记录，不运算</li></ul></li><li>Action<ul><li>输入是RDD</li><li>输出可能是某种计算结果（例如，一个数值或者一列数值）</li><li>当遇到Action时，需要返回结果，才真正执行已经记录的前面的运算</li></ul></li></ul><p>RDD运算过程：读入内存一次，在内存中可以多次处理</p><p>Spark编程</p><ul><li>Scala，同时对Java、Python提供API</li><li>Scala面向对象，函数式编程</li><li>Scala运行在JVM上</li></ul><p>容错/内存缓冲替换：当内存缓冲的RDD丢失的时候，可以重新执行记录的运算，重新计算这个RDD。</p><h2 id="数据流系统"><a href="#数据流系统" class="headerlink" title="数据流系统"></a>数据流系统</h2><p>概念：在流动的数据上实时地完成处理。</p><p>Twitter的Apache Storm，大部分功能代码是Java和Clojure（Clojure一种Lisp，编译成为JVM bytecode）混合实现，提供的编程接口主要为Java，通过Thrift支持各种编程语言。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MapReduce&quot;&gt;&lt;a href=&quot;#MapReduce&quot; class=&quot;headerlink&quot; title=&quot;MapReduce&quot;&gt;&lt;/a&gt;MapReduce&lt;/h2&gt;&lt;p&gt;MapReduce 是一个编程模型。&lt;/p&gt;
&lt;p&gt;并行分布式程序设计非常不容易，涉及到很多方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多线程编程&lt;/li&gt;
&lt;li&gt;socket编程&lt;/li&gt;
&lt;li&gt;job的调度、协同、worker之间的负载均衡&lt;/li&gt;
&lt;li&gt;节点的容错&lt;/li&gt;
&lt;li&gt;分布式系统的debug比较困难&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MapReduce的整体思路就是：让 程序员 写 串行程序，并行分布式计算平台提供一些接口（比如Map、Reduce），并将其并行分布式地执行。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式系统" scheme="http://lioncruise.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式系统" scheme="http://lioncruise.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="分布式计算" scheme="http://lioncruise.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>《大数据系统与数据分析》之关系型数据库</title>
    <link href="http://lioncruise.github.io/2017/04/15/big-data-relational-database/"/>
    <id>http://lioncruise.github.io/2017/04/15/big-data-relational-database/</id>
    <published>2017-04-15T10:30:53.000Z</published>
    <updated>2018-01-14T12:53:10.989Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><p>关系型数据库：关系代数</p><p>事务处理</p><p>数据仓库：OLAP（在线联机分析处理）、ETL（extract、transform、load）。用不同处数据源收集数据，面向某个主题按维度集成到一起。</p><p>离线批处理</p><p>实时数据流处理</p><a id="more"></a><p>大数据的概念：3V。volume：数据量巨大。velocity：数据产生快。variety：数据种类繁多。</p><p>RDB、NoSQL、数据仓库、离线批处理（Hadoop）、内存计算（Spark）、实时流处理。</p><p>关系型数据库主要关系运算：</p><ul><li>selection（选择）：用一个表中提取一些行</li><li>projection（投影）</li><li>join（连接）</li></ul><p>连接的类型：</p><ul><li>等值连接：如果R.a=S.b为条件的连接。如果a有m行的值为x，b有n行的值为x，那么这些行等值连接的结果由m*n个。</li><li>自然连接</li><li>内连接</li><li>左连接</li><li>右连接</li><li>全连接</li></ul><p>分组、聚合函数。</p><p>having子句，在group by的基础上再进行选择。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Major, <span class="keyword">count</span>(*) <span class="keyword">as</span> Cnt <span class="keyword">from</span> Student <span class="keyword">where</span> <span class="keyword">Year</span> &gt;= <span class="number">2012</span> <span class="keyword">and</span> <span class="keyword">Year</span> &lt;= <span class="number">2014</span> <span class="keyword">group</span> <span class="keyword">by</span> Major <span class="keyword">having</span> Cnt &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>DBMS（数据库管理系统）：是一种软件。</p><p>目前主流的3大商用关系型数据库：Oracle、SQL Server、DB2</p><p>关系型数据库系统架构：</p><ol><li>SQL语法解析（看SQL是否有语法错误）</li><li>查询优化（优化后SQL的语法树，即生成 <strong>查询计划</strong> ）</li><li>执行引擎（根据查询计划，访问数据，然后实现关系运算）</li><li>缓冲池（在内存中缓存硬盘的数据）</li><li>事务管理（目标ACID、写操作的log，并发读写时的lock）</li><li>数据存储和索引（如何高效地存储访问硬盘上的数据，数据结构）</li></ol><p>数据库 vs 文件系统</p><p>文件系统</p><ul><li>存储的是文件</li><li>通用的，可以存储任何数据和程序</li><li>文件是无结构的，是一串字节组成的</li><li>在操作系统的内核中实现</li><li>因为在内核中实现，所以对外提供基本的变成接口（系统调用），比如open、close、read、write。</li></ul><p>数据库</p><ul><li>存储的是数据表</li><li>存储的是特定结构的数据，比如关系型、KV型等</li><li>数据库是在用户程序中实现</li><li>对外提供DBMS的功能</li></ul><p>硬盘上最小存储访问单位为一个扇区：512B。</p><p>文件系统访问硬盘的单位通常为4KB（和一个内存页的大小一样？）</p><p>RDBMS最小的存储单位是database page size。database page size 可以设置为1到多个文件系统的page，比如4KB、8KB、16KB等。</p><p>database page 的内部结构。由tuple组成。</p><p>顺序访问。顺序访问会顺序读取某个表中的每个page，然后对于每个page，顺序访问每个tuple。检查选择条件是否成立，成立就将其选择出来。</p><p>index（索引）：有选择性的访问，区别于顺序访问。</p><ul><li>tree index：有序的，支持 <strong>点查询</strong>（a=1） 和 <strong>范围查询</strong>(a&gt;1这样的条件在tree index下也能用上索引)</li><li>hash index：无序的，只支持 <strong>点查询</strong></li></ul><p>树形索引实现的重要数据结构：B+树</p><p>B+树。每个节点是一个page。所有key都存在 叶子节点。非叶子节点 完全是起索引作用。</p><p>然后B+树相比B树，有一个非常重要的改进，就是叶子节点全部连起来了。</p><p>B+树的查找（搜索）：用 根节点 到 叶子节点。每个节点中进行 二分查找。找到了叶子节点，就找到了匹配项。</p><p>用B+树搜索的代价：假设共有N个节点（key），每个节点中包含B个值，那么总的I/O次数=B+树的高度：O(logBN)。总的比较次数：每个节点内部二分查找O(log2B)，O(logBN)*O(log2B)=O(log2N)。用B+树不用二叉树的优势在于可以极大减小索引查找时IO的次数。</p><p>当如节点，当节点慢了的时候，需要让B+树的节点分裂。</p><p>那么，这里有一个问题。一个建立了B+树索引的列，当查找的值为 NULL 的时候，是否会命中索引呢？</p><p><a href="https://stackoverflow.com/questions/289001/does-mysql-index-null-values" target="_blank" rel="noopener">Does mysql index null values?</a>。根据这个回答，MySQL其实在IS NULL这种写法上做了优化，将其当做某个常数值，借此达到了建立索引的效果。MySQL官方文档的解释：<a href="https://dev.mysql.com/doc/refman/5.7/en/is-null-optimization.html" target="_blank" rel="noopener">IS NULL Optimization</a></p><p>数据缓冲池：减少磁盘IO，提高性能。</p><p>访问的局部性：</p><ul><li>时间局部性：同一个数据元素可能会在一段时间内多次被访问</li><li>空间局部性：位置相近的数据元素可能会被一起访问（page为读写单位）</li></ul><p>数据库缓冲池 的 内存单元 分成database page大小的单元，每个内存单元可以缓冲一个数据库上的磁盘单元（database page）。</p><p>缓冲池的缓存替换策略，和OS内存换页比较像。通常是LRU，因为其是符合访问局部性原理的。</p><p>CLOCK算法</p><h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><p>ACID：</p><ul><li>原子性：一个事务里的操作，要么全部执行，要么全部不执行。</li><li>一致性：从一个正确状态转换到另一个正确状态（比如转账前后），一致性这个概念很多时候是自己定义的。</li><li>隔离性：每个事务与其他并发事务互不影响。</li><li>持久性：事务commit之后，结果持久有效。</li></ul><p>判断一组并发事务是否正确执行的标准：可串行化（并行执行结果=某个顺序的穿行执行结果）。</p><p>并发事务可能造成的问题：</p><ul><li>读脏：比如，在T2 commit 之前，T1读了T2已经修改了但是没有commit 的数据。</li><li>不可重复读：在T2 commit 之前，T1写了T2已经读的数据并且T1已经在T2之前 commit，如果T2再次读同一个数据，那么将发现读取的是同的值。（不可重复读，即一个事务两次读到的东西不一致，然后可能导致逻辑错误）。</li><li>更新丢失：在T2 commit 之前，T1已经重写了T2已经修改了的数据。</li></ul><p>MySQL 事务的4个隔离级别</p><ul><li>读未提交：脏读、不可重复读、更新丢失都可能发生。</li><li>读已提交：不可重复读、更新丢失可能会发生。</li><li>可重复读：更新丢失可能发生。</li><li>串行化：完全安全的级别，但是这样会极大影响效率，死锁的发生概率也会极大地增加。</li></ul><p>两大类解决方案：</p><p>悲观</p><ul><li>假设：数据竞争可能经常出现</li><li>防止机制：采用某种机制确保数据竞争不会出现。比如，如果一个事务 T1可能和正在运行的其它事务有冲突，那么就让这个T1等待，一直等到有冲突的其它所有事务都完成为止，才开始执行。</li></ul><p>乐观</p><ul><li>假设：数据竞争很少见</li><li>检查机制：<ul><li>允许所有事务都直接执行</li><li>但是事务不直接修改数据，而是把修改保留起来</li><li>当事务结束时，检查这些修改是否有数据竞争。没有竞争，成功结束，真正修改数据；如果有竞争，丢弃结果，重新计算。</li></ul></li></ul><p>悲观并发控制机制：使用加锁实现。对事务中的读写数据进行加锁，通常采用 <strong>两阶段加锁</strong>（2PL）。</p><p>两阶段加锁 的过程：</p><ol><li>在Transaction开始时，对每个需要访问的数据加锁。如果不能加锁，就一直等待，直到加锁成功。</li><li>执行Transaction的内容。</li><li>在Transaction commit前，集中对这个事务加锁的数据进行解锁</li><li>提交事务</li></ol><p>有一个集中的加锁阶段和一个集中的解锁阶段，由此得名。</p><p>思考的一个问题，锁的粒度？对表、行加锁？</p><p>读锁？写锁？</p><p>S锁（共享锁）：保护读操作</p><p>X锁（排它锁）：保护写操作</p><p>意向锁（Intent Locks）：</p><ul><li>IS（意向共享锁）：IS(a)将对a下面更细粒度的数据元素进行读</li><li>IX（意向排它锁）：IX(a)将对a下面更细粒度的数据元素进行写</li></ul><p>为了得到S、IS:，所有祖先必须为IS或IX；为了得到X、IX，所有祖先必须为IX。</p><p>乐观并发控制方案：Snapshot Isolation等。</p><p>Snapshot Isolation</p><ul><li>snapshot：一个时间点的数据库状态（快照）。</li><li>做法：在事务开始的时候，读这个snapshot的数据，将事务的更新先临时保存起来，在commit时检查版本有无冲突，有冲突就abort这个事务，然后重试。先提交的事务win。</li></ul><p><img src="/img/SnapshotIsolation.png" alt="Snapshot Isolation"></p><p>MVCC（Multiversion Concurrency Control）是 Snapshot Isolation 的一种实现。</p><p>某些情况下，MVCC并不是 串行等价 的。入下图：</p><p><img src="/img/MVCC不可串行化.png" alt="MVCC不可串行化的情况"></p><p>事务的 持久性 如何实现？</p><p>解决方案：WAL（Write Ahead Logging）</p><p>事务日志（Transactional Logging）：对事务中每个写操作会产生一个日志记录，对事务的commit会产生一个commit日志记录，对事务的abort会产生一个abort日志记录。</p><p>日志记录 被追加（append）到日志文件末尾。<strong>日志文件</strong> 是一个 append-only 的文件，每条日志记录有一个LSN（Log Sequence Number，是一个不断递增的整数，唯一代表一个记录；每产生一个日志记录，LSN +1），日志文件 中 日志记录 按照 LSN 顺序添加。</p><p>什么是Write-Ahead？</p><ul><li>Logging总是 优先于 实际的操作</li><li>Logging相当于是意向，先记录意向，然后再实际的写操作</li><li>先记录commit或abort的日志记录，然后再commit或abort</li></ul><p>根据commit日志，知道事务是否已经commit。如果因为掉电导致事务没有提交，可以根据日志记录的写操作进行恢复。</p><p>保证事务日志的持久性：write + flush。必须执行一个写操作，然后用 flush 保证写操作确实写到硬盘上了，并且等待 flush 结束。</p><p>如果一个事务要修改的记录很多，那么一个一个将日志写到硬盘肯定会非常慢。可以在在内存中分配一个 缓冲区 （Log Buffer），批量的写多条日志记录。</p><p>检查点（Checkpoint）</p><p>使用 检查点 机制可以使崩溃恢复时间可控。如果没有checkpoint，可能需要读整个日志，redo/undo很多工作。定期执行checkpoint。</p><p>日志文件 不可能无限增长。当事务完成，更新操作写入到磁盘后，就可以把这之前的日志记录都删除掉。</p><p>当事务正在进行的时候，机器崩溃了，然后就有一个 Crash Recovery 机制。</p><p>ARIES算法：</p><ul><li>分析阶段（找到日志的最后一个 检查点，找到日志崩溃点，确定崩溃时的活跃事务和脏页）</li><li>redo阶段（把系统恢复到崩溃前瞬间的状态）</li><li>undo阶段（清楚未提交的事务的修改）</li></ul><h2 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h2><p>关键词：OLAP、ETL</p><p>特点：</p><ul><li>集成的，采集自多个数据源</li><li>面向主题的，支持决策</li><li>反映历史变化</li><li>能够按维度查询</li><li>只读（没有修改操作），分析操作</li></ul><p>数据仓库是OLAP的基础。OLAP的基本数据模型是多维矩阵（数据立方体）。</p><p>数据立方体 的操作：roll up（上卷）、drill down（下钻）。</p><p><img src="/img/数据立方体上卷.png" alt="上卷"></p><p><img src="/img/数据立方体下钻.png" alt="下钻"></p><p>在一个维度上有可能定义层级：</p><ul><li>时间：年-月-日</li><li>地点：国-省-市</li></ul><p>roll up：在某个维度上求和，降维，从细粒度到粗粒度。drill down：将某个维度的和分解，增维，从粗粒度到细粒度。</p><p>slice（切片）：在某维上选一个值。</p><p><img src="/img/数据立方体切片.png" alt="切片"></p><p>dice（切块）：在多维上选多个值。</p><p><img src="/img/数据立方体切块.png" alt="切块"></p><h2 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h2><p>关键技术：</p><ul><li>Partition（划分）：将数据分布到多台服务器上</li><li>Replication（备份）：提高可用性、容灾</li></ul><p>分布式事务：一个事务读写的数据分布式在不同的机器上。</p><p>两阶段提交（2PC）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关系型数据库&quot;&gt;&lt;a href=&quot;#关系型数据库&quot; class=&quot;headerlink&quot; title=&quot;关系型数据库&quot;&gt;&lt;/a&gt;关系型数据库&lt;/h2&gt;&lt;p&gt;关系型数据库：关系代数&lt;/p&gt;
&lt;p&gt;事务处理&lt;/p&gt;
&lt;p&gt;数据仓库：OLAP（在线联机分析处理）、ETL（extract、transform、load）。用不同处数据源收集数据，面向某个主题按维度集成到一起。&lt;/p&gt;
&lt;p&gt;离线批处理&lt;/p&gt;
&lt;p&gt;实时数据流处理&lt;/p&gt;
    
    </summary>
    
      <category term="分布式系统" scheme="http://lioncruise.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式系统" scheme="http://lioncruise.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="关系型数据库" scheme="http://lioncruise.github.io/tags/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="事务" scheme="http://lioncruise.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="数据仓库" scheme="http://lioncruise.github.io/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Python的virtualenv</title>
    <link href="http://lioncruise.github.io/2016/12/20/virtualenv/"/>
    <id>http://lioncruise.github.io/2016/12/20/virtualenv/</id>
    <published>2016-12-20T02:32:21.000Z</published>
    <updated>2018-01-14T12:52:32.173Z</updated>
    
    <content type="html"><![CDATA[<p>最近刚刚进入今日头条实习，公司内部代码大多数使用Python写的。这几天系统地看了一下Python，发现了virtualenv这个非常实用的工具。</p><p>我们在开发Python应用程序的时候，系统安装的Python 3只有一个版本，所有第三方的包都会被pip安装到Python3的site-packages目录下。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">site-packages $ pwd</span><br><span class="line">/usr/local/lib/python3.6/site-packages</span><br><span class="line">site-packages $ ls</span><br><span class="line">Flask-0.12.dist-info             mysql_connector-2.1.4.dist-info</span><br><span class="line">Jinja2-2.9.4.dist-info           pip</span><br><span class="line">MarkupSafe-0.23-py3.6.egg-info   pip-9.0.1-py3.6.egg-info</span><br><span class="line">SQLAlchemy-1.1.4-py3.6.egg-info  pkg_resources</span><br><span class="line">Werkzeug-0.11.15.dist-info       setuptools</span><br><span class="line">__pycache__                      setuptools-32.2.0-py3.6.egg-info</span><br><span class="line">click                            sitecustomize.py</span><br><span class="line">click-6.7.dist-info              sqlalchemy</span><br><span class="line">easy_install.py                  virtualenv-15.1.0.dist-info</span><br><span class="line">flask                            virtualenv.py</span><br><span class="line">itsdangerous-0.24-py3.6.egg-info virtualenv_support</span><br><span class="line">itsdangerous.py                  werkzeug</span><br><span class="line">jinja2                           wheel</span><br><span class="line">markupsafe                       wheel-0.29.0-py3.6.egg-info</span><br><span class="line">mysql</span><br></pre></td></tr></table></figure><a id="more"></a><p>如果我们要同时开发多个应用程序，那这些应用程序都会共用一个Python，就是安装在系统的Python 3。如果应用A需要jinja 2.7，而应用B需要jinja 2.6怎么办？</p><p>这种情况下，每个应用可能需要各自拥有一套“独立”的Python运行环境。virtualenv就是用来为一个应用创建一套“隔离”的Python运行环境。</p><p>首先安装virtualenv：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip3 install virtualenv</span><br></pre></td></tr></table></figure><p>检查安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ virtualenv --version</span><br></pre></td></tr></table></figure><p>创建一个独立的Python运行环境，命名为venv:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cd myproject</span><br><span class="line">$ virtualenv --no-site-packages venv</span><br><span class="line">Using base prefix &apos;/usr/local/Cellar/python3/3.6.0/Frameworks/Python.framework/Versions/3.6&apos;</span><br><span class="line">New python executable in /Users/qinshijun/git/myproject/venv/bin/python3.6</span><br><span class="line">Also creating executable in /Users/qinshijun/git/myproject/venv/bin/python</span><br><span class="line">Installing setuptools, pip, wheel...done.</span><br></pre></td></tr></table></figure><p>命令virtualenv就可以创建一个独立的Python运行环境，我们还加上了参数–no-site-packages，这样，已经安装到系统Python环境中的所有第三方包都不会复制过来，我们就得到了一个不带任何第三方包的“干净”的Python运行环境。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myproject $ ls</span><br><span class="line">venv</span><br><span class="line">myproject $ source venv/bin/activate</span><br><span class="line">(venv) myproject $</span><br></pre></td></tr></table></figure><p>注意到命令提示符变了，有个(venv)前缀，表示当前环境是一个名为venv的Python环境。并且我们可以看到，执行的python和pip命令不再是默认的python和pip命令的路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(venv) myproject $ which python</span><br><span class="line">/Users/qinshijun/git/myproject/venv/bin/python</span><br><span class="line">(venv) myproject $ which pip</span><br><span class="line">/Users/qinshijun/git/myproject/venv/bin/pip</span><br></pre></td></tr></table></figure><p>下面正常安装各种第三方包，并运行python命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pip install flask</span><br><span class="line">$ python test.py</span><br></pre></td></tr></table></figure><p>在venv环境下，用pip安装的包都被安装到venv这个环境下，系统Python环境不受任何影响。也就是说，venv环境是专门针对myproject这个应用创建的。</p><p>退出当前的venv环境，使用deactivate命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(venv) myproject $ deactivate </span><br><span class="line">myproject $ which python</span><br><span class="line">/usr/bin/python</span><br></pre></td></tr></table></figure><p>此时就回到了正常的环境，现在pip或python均是在系统Python环境下执行。</p><p>使用virtualenv，我们完全可以针对每个应用创建独立的Python运行环境，这样就可以对每个应用的Python环境进行隔离。</p><p>那么virtualenv是如何创建“独立”的Python运行环境的呢？原理很简单，就是把系统Python复制一份到virtualenv的环境，用命令source venv/bin/activate进入一个virtualenv环境时，virtualenv会修改相关环境变量，让命令python和pip均指向当前的virtualenv环境。</p><p>虚拟环境是系统Python解释器的一个私有副本，在这个环境下可以安装隔离的私有包，而且不会影响到系统中全局Python解释器。从而避免系统中安装的全局Python解释器的包的混乱和冲突，使全局的Python解释器干净整洁，同时解决了不同应用间多版本的冲突问题。我认为这种工程思想非常借鉴。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近刚刚进入今日头条实习，公司内部代码大多数使用Python写的。这几天系统地看了一下Python，发现了virtualenv这个非常实用的工具。&lt;/p&gt;
&lt;p&gt;我们在开发Python应用程序的时候，系统安装的Python 3只有一个版本，所有第三方的包都会被pip安装到Python3的site-packages目录下。如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;site-packages $ pwd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/usr/local/lib/python3.6/site-packages&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;site-packages $ ls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Flask-0.12.dist-info             mysql_connector-2.1.4.dist-info&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Jinja2-2.9.4.dist-info           pip&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MarkupSafe-0.23-py3.6.egg-info   pip-9.0.1-py3.6.egg-info&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SQLAlchemy-1.1.4-py3.6.egg-info  pkg_resources&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Werkzeug-0.11.15.dist-info       setuptools&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;__pycache__                      setuptools-32.2.0-py3.6.egg-info&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;click                            sitecustomize.py&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;click-6.7.dist-info              sqlalchemy&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;easy_install.py                  virtualenv-15.1.0.dist-info&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;flask                            virtualenv.py&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;itsdangerous-0.24-py3.6.egg-info virtualenv_support&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;itsdangerous.py                  werkzeug&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;jinja2                           wheel&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;markupsafe                       wheel-0.29.0-py3.6.egg-info&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysql&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="http://lioncruise.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://lioncruise.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>TCP拥塞控制机制详解</title>
    <link href="http://lioncruise.github.io/2016/11/01/tcp-congestion-control/"/>
    <id>http://lioncruise.github.io/2016/11/01/tcp-congestion-control/</id>
    <published>2016-11-01T06:31:23.000Z</published>
    <updated>2018-01-14T12:54:18.362Z</updated>
    
    <content type="html"><![CDATA[<p>网络拥塞 (Congestion)是由多个传输流需要共享(争用)网络内资源造成的。当资源需求超过网络容量时，就会产生问题，每条流不知道当前网络资源分配情况，每条流也不知道其它(竞争)流的存在，从而导致丢包率升高、往返时间增大、甚至网络崩溃。如何协调网络内各条流，使其可以高效利用网络资源?</p><p><img src="/img/864982D0-7248-45A9-AD39-F09134C8B0E8.png" alt=""></p><a id="more"></a><p>拥塞控制（congestion control)是TCP协议的一项重要功能，TCP的拥塞控制机制是从端到端的角度，推测网络是否发生拥塞，如果推断网络发生拥塞，则立即将数据发送速率降下来，以便缓解网络拥塞。</p><p>TCP的拥塞控制采用的是窗口机制，通过调节窗口的大小实现对数据发送速率的调整。TCP的发送端维持一个称为拥塞窗口cwnd的变量，单位为字节，用于表示在未收到接收端确认的情况下，可以连续发送的数据字节数。cwnd的大小取决于网络的拥塞程度，并且动态地发生变化。拥塞窗口调整的原则是：只要网络没有出现拥塞，就可以增大拥塞窗口，以便将更多的数据发送出去，相当于提高发送速率；一旦网络出现拥塞，拥塞窗口就减小一些，减少注入网络的数据量，从而缓解网络的拥塞。</p><p>发送端判断网络发生拥塞的依据是：发送端设置一个重传计时器RTO，对于某个已发出的数据报文段，如果在RTO计时到期后，还没有收到来自接收端的确认，则认为此时网络发生了拥塞。</p><p>TCP的拥塞控制算法包括了慢启动（slow start）、拥塞避免（congestion avoidance）、快速重传（fast retransmit）和快速恢复（fast recovery）四部分。</p><p><img src="/img/FB75DA4B-9242-42DB-89DC-8224691E6452.png" alt=""></p><h2 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h2><p>慢启动算法作用在TCP数据传输的开始阶段，当主机开始发送数据时，因为不知道网络中的负荷情况，如果立即发送大量的数据，有可能会引起网络的拥塞。因此，TCP采用试探的方法，逐渐增大拥塞窗口。通常在刚开始发送数据报文段时，先将拥塞窗口cwnd设置为一个TCP最大段长度MSS的值。而在每收到一个数据报文段的确认后，cwnd就增加一个MSS的数值。这样就可以逐渐增大发送端的拥塞窗口，使数据注入网络的速率比较合理。如果定义从发送端发出一个数据报文段到收到这个数据报文段的确认的时间间隔为往返时间RTT，则在慢启动阶段，每经过一个RTT，cwnd的值就加倍。值得注意的是，慢启动并不是说启动过程增长慢，而是说初始的发送窗口小。</p><h2 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h2><p>为了防止拥塞窗口增长过快而引起网络拥塞，TCP还需要设置一个慢启动阈值ssthresh，当拥塞窗口的值增加到ssthresh时，就要减缓拥塞窗口的增长速度，具体的做法是每经过一个RTT，拥塞窗口cwnd的值加1（单位为MSS），这样就可以使cwnd按线性规律缓慢增长，这个过程称之为“加性增加”（Additive Increase）算法。通常情况下，拥塞窗口cwnd的初值被设置为1，慢启动阈值ssthresh的初值被设置为16。当拥塞避免算法执行到某个时刻，发送端在规定时间内没有收到接收端的确认，即发生了网络超时，则意味着网络发生了拥塞。此时，发送端首先将ssthresh的值变为发生超时时cwnd值的一半，同时将cwnd的值置为1，重新执行慢启动算法。这样做的好处是，当网络频繁出现拥塞时，ssthresh下降得很快，可以大大减少注入网络中的数据报文段。通常称这个过程为“乘性减小”（MultiplicativeDecrease）算法。TCP中的“加性增加”和“乘性减小”算法合起来称为AIMD算法。</p><p>慢启动和拥塞避免是 1988 年提出的拥塞控制算法， 1990 年在此基础上又增加了快速重传和快速恢复两个算法。</p><h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>快速重传算法的基本思想是：接收端每收到一个失序的数据报文段后就立即发出重复确认，以便更早地通知发送端有丢包的情况发生。假设在某个TCP数据传输过程中，接收端依次收到发送端发出的1号和2号数据报文段，并对这两个数据报文段发送确认后，没有按次序收到3号数据报文段，而是收到了4号，这时就需要立即向发送端发送一个2号数据报文段的确认，称为重复确认。同理，如果继续收到5号、6号数据报文段，接收端仍然要向发送端发出2号数据报文段的重复确认。此时，发送端会收到多个2号数据报文段的重复确认，则认为3号数据报文段发生了丢包，需要立即向接收端重传3号数据报文段，而不需要等待重传计时器到期再重传。快速重传算法中规定如果收到某数据报文段的三个重复确认，则立即重传下一个数据报文段。使用快速重传比用超时重传快很多，超时重传中间只能等待不能做任何事，而且又要重新慢启动，因此要尽量用快速重传。要知道，ACK指的是下一个期望的数据包，如果发送方一直收到ACK，说明接收方没有收到那个包，因此要快速重传。</p><p><img src="/img/4B972BAC-95D1-44FC-B15A-F2C6B3D85826.png" alt=""></p><h2 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h2><p>快速恢复是配合快速重传使用的算法，其基本思想是：当发送端连续收到三个重复确认时，就将慢启动阈值ssthresh减半，以预防网络拥塞的发生，并且将拥塞窗口cwnd的值置为减半后的ssthresh，然后开始执行拥塞避免算法，使得cwnd缓慢地加性增大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络拥塞 (Congestion)是由多个传输流需要共享(争用)网络内资源造成的。当资源需求超过网络容量时，就会产生问题，每条流不知道当前网络资源分配情况，每条流也不知道其它(竞争)流的存在，从而导致丢包率升高、往返时间增大、甚至网络崩溃。如何协调网络内各条流，使其可以高效利用网络资源?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/864982D0-7248-45A9-AD39-F09134C8B0E8.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="http://lioncruise.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="网络" scheme="http://lioncruise.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP" scheme="http://lioncruise.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法-堆排序</title>
    <link href="http://lioncruise.github.io/2016/10/30/heap-sort/"/>
    <id>http://lioncruise.github.io/2016/10/30/heap-sort/</id>
    <published>2016-10-30T02:01:58.000Z</published>
    <updated>2018-01-14T12:48:03.447Z</updated>
    
    <content type="html"><![CDATA[<p>前几天去某家公司面试，被要求手写和推导堆排序算法（比如建堆的时间复杂度为什么是O(n)），其实大二学了这个之后基本就没怎么看了，所以导致当是面试的情景很是尴尬。但堆排序其实是一个极其常见基础算法，写不出来真的不能怪面试官，还是自己基础不够扎实。那么下面就再来复习一下堆排序得原理。</p><p><img src="https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike72%2C5%2C5%2C72%2C24/sign=ce51ee89a6efce1bfe26c098ce3898bb/aa64034f78f0f736f17de17e0b55b319eac413c9.jpg" alt=""></p><a id="more"></a><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>要了解堆首先需要了解一下二叉树，在计算机科学中，二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树（BST）和二叉堆。</p><p>满二叉树：一棵深度为 k，且有 2<sup>k</sup> - 1 个节点称之为满二叉树。</p><p>下图是一棵深度为4的满二叉树。</p><p><img src="/img/full_binary_tree.png" alt=""></p><!--more--><p>完全二叉树：深度为 k，有 n 个节点的二叉树，当且仅当其每一个节点都与深度为 k 的满二叉树中序号为 1 至 n 的节点对应时，称之为完全二叉树。即前k-1层为满二叉树，第k层的结点都在该层的最左边。</p><p>下图是一棵深度为4的完全二叉树。</p><p><img src="/img/complete_binary_tree.png" alt=""></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆（二叉堆）可以视为一棵完全的二叉树。完全二叉树的一个“优秀”的性质是，除了最底层之外，其余每一层都是满的，这使得堆可以利用数组来表示（普通的一般的二叉树通常用链表作为基本容器表示），每一个结点对应数组中的一个元素。</p><p>如下图，是一个堆和数组的相互关系。</p><p><img src="/img/heap-and-array.png" alt=""></p><p>对于给定的某个节点的下标i，可以很容易的计算出这个结点的父结点、孩子结点的下标：</p><ul><li>Parent(i) = i/2 // i 的父节点下标</li><li>Left(i) = 2i // i 的左子节点下标</li><li>Right(i) = 2i + 1 // i 的右子节点下标</li></ul><p><img src="/img/heap-and-array-parent-children.png" alt=""></p><p>然后，堆（二叉堆）又分为2种：最大堆（大顶堆）、最小堆（小顶堆）。</p><h3 id="最大堆"><a href="#最大堆" class="headerlink" title="最大堆"></a>最大堆</h3><ul><li>堆中的最大元素值出现在根结点（堆顶）</li><li>堆中每个父节点的元素值都大于等于其孩子结点（如果存在）</li></ul><p><img src="/img/max-heap.png" alt=""></p><h3 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h3><ul><li>堆中的最小元素值出现在根结点（堆顶）</li><li>堆中每个父节点的元素值都小于等于其孩子结点（如果存在）</li></ul><p><img src="/img/min-heap.png" alt=""></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。在堆中定义以下几种操作：</p><ul><li>堆调整</li><li>建堆</li></ul><p>继续进行下面的讨论前，需要注意的一个问题是：数组都是 Zero-Based，这就意味着我们的堆数据结构模型要发生改变：</p><p><img src="/img/heap-and-array-zero-based.png" alt=""></p><p>相应的，几个计算公式也要作出相应调整：</p><ul><li>Parent(i) = (i-1)/2 // i 的父节点下标</li><li>Left(i) = 2i + 1 // i 的左子节点下标</li><li>Right(i) = 2i + 2 // i 的右子节点下标</li></ul><h3 id="堆调整"><a href="#堆调整" class="headerlink" title="堆调整"></a>堆调整</h3><p>最大堆调整（Max‐Heapify）的作用是保持最大堆的性质，是创建最大堆的核心子程序，作用过程如图所示：</p><p><img src="/img/MAX‐HEAPIFY-Procedure.png" alt=""></p><p>由于一次调整后，堆仍然违反堆性质，所以需要递归的测试，使得整个堆都满足堆性质，用 Java 可以表示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大堆调整</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 检查起始的下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> heapSize 堆大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;<span class="comment">// 左孩子的下标（如果存在的话）</span></span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">2</span> * index + <span class="number">2</span>;<span class="comment">// 左孩子的下标（如果存在的话）</span></span><br><span class="line">    <span class="keyword">int</span> iMax = index;<span class="comment">// 寻找3个节点中最大值节点的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; array[left] &gt; array[index])</span><br><span class="line">        iMax = left;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; array[right] &gt; array[iMax])</span><br><span class="line">        iMax = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iMax != index) &#123;</span><br><span class="line">        swap(array, iMax, index);</span><br><span class="line">        heapify(array, iMax, heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归在调用递归子函数的时候，会先将传给子函数的参数压栈，然后将当前指令的下一条指令的地址压栈，以便子函数执行完后返回到原函数中继续执行，在原函数继续执行之前还涉及到清理子函数的栈。因此，递归的效率比迭代低一点点。其实上面的调整堆也可以用迭代来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left, right, iMax;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        left = <span class="number">2</span> * index + <span class="number">1</span>;<span class="comment">// 左孩子的下标（如果存在的话）</span></span><br><span class="line">        right = <span class="number">2</span> * index + <span class="number">2</span>;<span class="comment">// 左孩子的下标（如果存在的话）</span></span><br><span class="line">        iMax = index;<span class="comment">// 寻找3个节点中最大值节点的下标</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; array[left] &gt; array[index])</span><br><span class="line">            iMax = left;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; array[right] &gt; array[iMax])</span><br><span class="line">            iMax = right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (iMax != index) &#123;</span><br><span class="line">            swap(array, iMax, index);</span><br><span class="line">            index = iMax;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><p>创建最大堆（Build-Max-Heap）的作用是将一个数组改造成一个最大堆，接受数组和堆大小两个参数，Build-Max-Heap 将自下而上的调用 Max-Heapify 来改造数组，建立最大堆。<strong>因为 Max-Heapify 能够保证下标 i 的结点之后结点都满足最大堆的性质，所以自下而上的调用 Max-Heapify 能够在改造过程中保持这一性质</strong>。如果最大堆的数量元素是 n，那么 Build-Max-Heap 从 Parent(n) 开始，往上依次调用 Max-Heapify。流程如下：</p><p><img src="/img/building-heap.png" alt=""></p><p>用 Java 描述如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = array.length;<span class="comment">// 数组中元素的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        heapify(array, i, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序（Heap-Sort）先调用Build-Max-Heap将原数组改造为最大堆，这个时候堆定元素最大，将其与堆底（当前堆对应数组的最后一个元素）交换，堆的大小减去1，当前堆堆底后面的元素已经排好序。然后，从堆顶元素开始检查，调用Max-Heapify保持最大堆性质，这样可以将第二大的元素调到堆顶，然后将其与当前堆堆底元素交换。重复这个过程n-1次，直到堆中只有1个元素为止。整个流程如下：</p><p><img src="/img/HeapSort.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        buildHeap(array);<span class="comment">// 构建堆</span></span><br><span class="line">        <span class="keyword">int</span> n = array.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            swap(array, <span class="number">0</span>, i);</span><br><span class="line">            heapify(array, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建最大堆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = array.length;<span class="comment">// 数组中元素的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            heapify(array, i, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大堆调整</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 检查起始的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heapSize 堆大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;<span class="comment">// 左孩子的下标（如果存在的话）</span></span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span> * index + <span class="number">2</span>;<span class="comment">// 左孩子的下标（如果存在的话）</span></span><br><span class="line">        <span class="keyword">int</span> iMax = index;<span class="comment">// 寻找3个节点中最大值节点的下标</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; array[left] &gt; array[index])</span><br><span class="line">            iMax = left;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; array[right] &gt; array[iMax])</span><br><span class="line">            iMax = right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (iMax != index) &#123;</span><br><span class="line">            swap(array, iMax, index);</span><br><span class="line">            heapify(array, iMax, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序时间复杂度"><a href="#堆排序时间复杂度" class="headerlink" title="堆排序时间复杂度"></a>堆排序时间复杂度</h2><p>堆排序是一种比较稳定的算法，平均的时间复杂度为O(nlogn)，最坏时间复杂度也是O(nlogn)。相对于快速排序来说，这是堆排序的最大优点。</p><p>建堆的时间复杂度为O(n)，推导过程就借用一下别人的了（n为结点的个数）:</p><p><img src="/img/2D1A23A2-AF3E-4384-84C6-430D62CB803D.png" alt=""></p><p>调整堆过程：1/2的结点向下比较了log(n)次，1/4的结点向下比较了log(n)-1次，…。将这些相加，得到O(nlogn)的结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天去某家公司面试，被要求手写和推导堆排序算法（比如建堆的时间复杂度为什么是O(n)），其实大二学了这个之后基本就没怎么看了，所以导致当是面试的情景很是尴尬。但堆排序其实是一个极其常见基础算法，写不出来真的不能怪面试官，还是自己基础不够扎实。那么下面就再来复习一下堆排序得原理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike72%2C5%2C5%2C72%2C24/sign=ce51ee89a6efce1bfe26c098ce3898bb/aa64034f78f0f736f17de17e0b55b319eac413c9.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://lioncruise.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://lioncruise.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://lioncruise.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>字符串匹配的KMP算法</title>
    <link href="http://lioncruise.github.io/2016/10/08/kmp/"/>
    <id>http://lioncruise.github.io/2016/10/08/kmp/</id>
    <published>2016-10-08T01:06:27.000Z</published>
    <updated>2018-01-14T12:49:34.222Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">阮一峰老师的博客</a>。</p><p>字符串匹配是计算机的基本任务之一。</p><p>举例来说，有一个字符串<code>&quot;BBC ABCDAB ABCDABCDABDE&quot;</code>，我想知道，里面是否包含另一个字符串<code>&quot;ABCDABD&quot;</code>？</p><p>许多算法可以完成这个任务，Knuth-Morris-Pratt算法（简称KMP）是最常用的之一。它以三个发明者命名，起头的那个K就是著名科学家Donald Knuth。</p><p>这种算法不太容易理解，网上有很多解释，但读起来都很费劲。直到读到Jake Boxer的文章，我才真正理解这种算法。下面，我用自己的语言，试图写一篇比较好懂的KMP算法解释。</p><p>1.</p><p><img src="http://image.beekka.com/blog/201305/bg2013050103.png" alt=""></p><p>首先，字符串”BBC ABCDAB ABCDABCDABDE”的第一个字符与搜索词”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。</p><a id="more"></a><p>2.</p><p><img src="http://image.beekka.com/blog/201305/bg2013050104.png" alt=""></p><p>因为B与A不匹配，搜索词再往后移。</p><p>3.</p><p><img src="http://image.beekka.com/blog/201305/bg2013050105.png" alt=""></p><p>就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止。</p><p>4.</p><p><img src="http://image.beekka.com/blog/201305/bg2013050106.png" alt=""></p><p>接着比较字符串和搜索词的下一个字符，还是相同。</p><p>5.</p><p><img src="http://image.beekka.com/blog/201305/bg2013050107.png" alt=""></p><p>直到字符串有一个字符，与搜索词对应的字符不相同为止。</p><p>6.</p><p><img src="http://image.beekka.com/blog/201305/bg2013050108.png" alt=""></p><p>这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。</p><p>7.</p><p><img src="http://image.beekka.com/blog/201305/bg2013050107.png" alt=""></p><p><strong>一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是”ABCDAB”</strong>。<strong>KMP算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率</strong>。</p><p>8.</p><p><img src="http://image.beekka.com/blog/201305/bg2013050109.png" alt=""></p><p>怎么做到这一点呢？可以针对搜索词，算出一张<strong>《部分匹配表》</strong>（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了。</p><p>9.</p><p><img src="http://image.beekka.com/blog/201305/bg2013050107.png" alt=""></p><p>已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数：</p><p><code>移动位数 = 已匹配的字符数 - 对应的部分匹配值</code></p><p>因为 6 - 2 等于4，所以将搜索词向后移动4位。</p><p>10.</p><p><img src="http://image.beekka.com/blog/201305/bg2013050110.png" alt=""></p><p>因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。</p><p>11.</p><p><img src="http://image.beekka.com/blog/201305/bg2013050111.png" alt=""></p><p>因为空格与A不匹配，继续后移一位。</p><p>12.</p><p><img src="http://image.beekka.com/blog/201305/bg2013050112.png" alt=""></p><p>逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。</p><p>13.</p><p><img src="http://image.beekka.com/blog/201305/bg2013050113.png" alt=""></p><p>逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。</p><p>14.</p><p><img src="http://image.beekka.com/blog/201305/bg2013050114.png" alt=""></p><p>下面介绍《部分匹配表》是如何产生的。</p><p>首先，要了解两个概念：”前缀”和”后缀”。 “前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。</p><p>15.</p><p><img src="http://image.beekka.com/blog/201305/bg2013050109.png" alt=""></p><p>“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例，</p><ul><li>“A”的前缀和后缀都为空集，共有元素的长度为0；</li><li>“AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；</li><li>“ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；</li><li>“ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；</li><li>“ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1；</li><li>“ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2；</li><li>“ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。</li></ul><p>16.</p><p><img src="http://image.beekka.com/blog/201305/bg2013050112.png" alt=""></p><p><strong>“部分匹配”的实质是，有时候，字符串头部和尾部会有重复</strong>。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阮一峰老师的博客&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;字符串匹配是计算机的基本任务之一。&lt;/p&gt;
&lt;p&gt;举例来说，有一个字符串&lt;code&gt;&amp;quot;BBC ABCDAB ABCDABCDABDE&amp;quot;&lt;/code&gt;，我想知道，里面是否包含另一个字符串&lt;code&gt;&amp;quot;ABCDABD&amp;quot;&lt;/code&gt;？&lt;/p&gt;
&lt;p&gt;许多算法可以完成这个任务，Knuth-Morris-Pratt算法（简称KMP）是最常用的之一。它以三个发明者命名，起头的那个K就是著名科学家Donald Knuth。&lt;/p&gt;
&lt;p&gt;这种算法不太容易理解，网上有很多解释，但读起来都很费劲。直到读到Jake Boxer的文章，我才真正理解这种算法。下面，我用自己的语言，试图写一篇比较好懂的KMP算法解释。&lt;/p&gt;
&lt;p&gt;1.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.beekka.com/blog/201305/bg2013050103.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先，字符串”BBC ABCDAB ABCDABCDABDE”的第一个字符与搜索词”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://lioncruise.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://lioncruise.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="查找" scheme="http://lioncruise.github.io/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java中的volatile关键字</title>
    <link href="http://lioncruise.github.io/2016/02/11/java-volatile/"/>
    <id>http://lioncruise.github.io/2016/02/11/java-volatile/</id>
    <published>2016-02-11T07:22:26.000Z</published>
    <updated>2018-01-14T12:57:09.227Z</updated>
    
    <content type="html"><![CDATA[<p><strong>volatile关键字可以算得上是JVM提供的最轻量级的同步机制</strong>，但是它比较难以被完整正确的理解，我在之前也看了一些volatile的文章，但是看完之后都感觉在云里雾里。以至于很多人都不习惯去用它，遇到多线程竞争资源的场景一律使用synchronized关键字进行同步。了解volatile变量的语义对了解多线程操作的其它特性很有意义，下面我们就来看一下volatile的语义是什么？</p><a id="more"></a><p>首先，不用那么通俗易懂的语言介绍一下这个关键字的作用。</p><p>当一个变量定义为volatile之后，它将具备两种特性。</p><p>第一，<strong>保证此变量对所有线程的可见性</strong>，这里的“可见性”是指当一个线程修改了这个变量的值，新的值对于其它线程来说是立即得知的。而普通的变量不能做到这一点，普通变量的值在线程间传递均需要通过共享内存。例如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一个线程B在线程A回写完成了之后再从共享内存进行读取操作，新变量才会对线程B可见。</p><p>关于volatile变量的可见性，经常会被开发人员误解，认为以下描述成立：“volatile变量对所有线程是立即可见的，对volatile变量所有的写操作都能立即返回到其它线程中，换句话说，volatile变量在各线程中都是一致的，所以基于volatile变量的运算在并发下是安全的”。因此，<strong>volatile很容易被误用，用来进行原子性操作</strong>。<strong>这句话前面并没有错，但是不能得到“volatile修饰的变量在并发下一定是安全的”这个结论</strong>。</p><p><strong>volatile变量在各个线程的工作栈中不存在一致性问题</strong>（在各个线程的工作栈中，volatile变量也可以存在不一致的情况，但是由于每次使用之前都要刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题），<strong>但是Java里面的运算并非原子操作</strong>，导致volatile变量的运算在并发下一样是不安全的，我们可以看一下下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> race = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[THREADS_COUNT];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                        increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有累加线程都结束</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">1</span>)</span><br><span class="line">            Thread.yield();</span><br><span class="line"></span><br><span class="line">        System.out.println(race);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码发起了20个线程，每个线程对race变量进行10000次自增操作。如果这段代码能够正确并发的话，最后输出结果应该是200000。但是我运行了几次，结果分别是72597、83889、68223，都是一个小于200000的结果。</p><p>这是为什么呢？问题就在自增运算<code>race++;</code>上，我们用javap反编译这段代码后，发现只有一行的increase()方法在Class文件中是由4条字节码指令构成（并不是一个原子操作，不可拆分的操作）。从字节码层面上很容易就能分析出并发失败的原因了：当getstatic指令把race的值取到操作栈顶时（<strong>用volatile修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最的值</strong>），volatile关键字保证了race的值在此时是正确的，但是在执行iconst_1、iadd的时候，其它线程可能已经把race的值增大了，而在操作栈顶的值就变成了过期的数据，所以putstatic执行后就可能把较小的race值同步到共享内存之中。</p><p><code>race++;</code>的Class字节码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic</span><br><span class="line">iconst_1</span><br><span class="line">iadd</span><br><span class="line">putstatic</span><br></pre></td></tr></table></figure><p>客观来讲，这里用字节码来分析并发问题，仍然是不严谨的，因为一条字节码指令也不一定是一个原子操作。</p><p><strong>由于volatile变量只能保证可见性，不能保证原子性</strong>。在不符合一下两条规则的运算场景中，我们仍然要通过加锁（比如使用synchronized关键字）来保证原子性。</p><ul><li>运算结果并不依赖变量的当前值，或者能够保证只有单一的线程修改变量的值。</li><li>变量不需要与其它的状态变量共同参与不变约束。</li></ul><p>像如下的代码的这类场景就很适合使用volatile变量来控制并发，当shutdown()被调用的时候，能保证所有线程中执行的doWork()方法都停下来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> isShutdown;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    isShutdown = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!isShutdown)&#123;</span><br><span class="line">        <span class="comment">// do stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;volatile关键字可以算得上是JVM提供的最轻量级的同步机制&lt;/strong&gt;，但是它比较难以被完整正确的理解，我在之前也看了一些volatile的文章，但是看完之后都感觉在云里雾里。以至于很多人都不习惯去用它，遇到多线程竞争资源的场景一律使用synchronized关键字进行同步。了解volatile变量的语义对了解多线程操作的其它特性很有意义，下面我们就来看一下volatile的语义是什么？&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://lioncruise.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://lioncruise.github.io/tags/Java/"/>
    
      <category term="Java并发编程" scheme="http://lioncruise.github.io/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JVM类加载机制</title>
    <link href="http://lioncruise.github.io/2016/02/10/jvm-class-load/"/>
    <id>http://lioncruise.github.io/2016/02/10/jvm-class-load/</id>
    <published>2016-02-10T13:32:07.000Z</published>
    <updated>2018-01-14T12:56:55.200Z</updated>
    
    <content type="html"><![CDATA[<p>JVM将Class文件（.java文件编译产生的二进制字节流）中的信息加载到内存中，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是JVM的类加载机制。</p><p>JVM中类加载类的过程主要如下图所示：</p><p><img src="/img/251937420687138.jpg" alt=""></p><p>与那些在编译时需要进行连接工作的语言不同（比如C语言，C语言的编译是先将C源文件编译成中间文件，然后再在编译期间将这些中间文件连接，这样速度比较快，但是调用相当于写死了），Java的类型加载、连接和初始化过程都是在程序运行期间完成的，这种策略提供了高度的灵活性。Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。例如，如果编写一个面相接口的应用程序，可以等到运行时再指定其实际的实现类。</p><a id="more"></a><h2 id="什么时候加载一个类？"><a href="#什么时候加载一个类？" class="headerlink" title="什么时候加载一个类？"></a>什么时候加载一个类？</h2><p>什么时候要加载类？Java虚拟机规范中并没有强制约束，但是加载必须在初始化之前。</p><ol><li>遇到new（实例化对象）、getstatic（操作静态字段）、putstatic、invokestatic（调用类的静态方法）这4条字节码指令。如果类没有进行初始化，则需要先触发其初始化。</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。</li><li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先对其父类进行初始化。</li><li>当虚拟机启动的时候，用户需要指定一个执行的主类（包括main方法的那个类），JVM会先初始化这个主类。</li><li>被final修饰的静态字段，在编译起已经把结果放入常量池，这种情况不会引发类的加载。</li></ol><p>类被加载的时候，它的静态块执行。</p><p>一个类在初始化时，要求其父类全部已经初始化过了。但是一个接口在初始化时，并不要求其父接口都完成了初始化，只有在真正使用到父接口的时候（比如引用接口中定义的常量）才会初始化。</p><h2 id="加载（阶段）"><a href="#加载（阶段）" class="headerlink" title="加载（阶段）"></a>加载（阶段）</h2><p>加载阶段，JVM完成3件事：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ol><p>这个二进制流不一定非要从.class文件中获取，也可以从JAR、WAR包中读取，可以运行时计算生成，这种场景用的最多的就是动态代理技术。还可以从其他文件，比如JSP中生成对应的Class类。</p><p>加载过程可以使用系统提供的类加载器来完成，也可以使用用户自定义的类加载器完成（即自己重写一个类加载器的loadClass()方法）。</p><p>数组类的加载的情况有些不同，数组类本身不通过类加载器创建，它是由JVM直接创建的。但是，数组类中的元素类型最终还是要靠类加载器去创建。</p><p><strong>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区中。</strong>然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定在Java堆中，比如HotSpot中它就在方法区）。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>确保二进制字节流中包含的信息符合当前虚拟机的要求，并不会危害到虚拟机自身安全。</p><p>文件格式验证：二进制字节流是否符合Class文件格式的规范，并且能当前版本的虚拟机处理。</p><p>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范要求。</p><p>字节码验证：通过数据流和控制流分析，确定程序语义是合法合逻辑的。</p><p>符号引用验证：确保解析动作可以正常执行。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段正式为类变量（被static修饰的变量，不包括实例变量）分配内存并设置类变量初始值的阶段，这些变量所使用的内存都在方法区进行分配。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程。</p><ol><li>类或接口解析</li><li>字段解析：从下往上（从子类往父类）匹配字段，填写字段表</li><li>类方法解析：从下往上（从子类往父类）匹配方法名，填写方法表</li><li>接口方法解析</li></ol><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化阶段才真正开始执行类中定义的Java代码（或者说字节码）。初始化是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程（区别new对象的构造方法）。<code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量（静态变量）的赋值动作和静态语句块（static块）中的语句合并而成。</p><p>虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。因此虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code>方法的类肯定是java.lang.Object。</p><p><code>&lt;clinit&gt;()</code>方法对类或接口来说并不是必要的，如果一个类中没有静态语句块和对类变量的赋值，也就没有对类变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法。</p><p>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>()方法在多线程环境下被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>()方法，其他线程都要等待，直到活动线程执行<code>&lt;clinit&gt;()</code>()方法完毕。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JVM将Class文件（.java文件编译产生的二进制字节流）中的信息加载到内存中，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是JVM的类加载机制。&lt;/p&gt;
&lt;p&gt;JVM中类加载类的过程主要如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/251937420687138.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;与那些在编译时需要进行连接工作的语言不同（比如C语言，C语言的编译是先将C源文件编译成中间文件，然后再在编译期间将这些中间文件连接，这样速度比较快，但是调用相当于写死了），Java的类型加载、连接和初始化过程都是在程序运行期间完成的，这种策略提供了高度的灵活性。Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。例如，如果编写一个面相接口的应用程序，可以等到运行时再指定其实际的实现类。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://lioncruise.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://lioncruise.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="http://lioncruise.github.io/tags/JVM/"/>
    
      <category term="Java类加载" scheme="http://lioncruise.github.io/tags/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>类加载器与双亲委派模型</title>
    <link href="http://lioncruise.github.io/2016/02/10/classloader/"/>
    <id>http://lioncruise.github.io/2016/02/10/classloader/</id>
    <published>2016-02-10T00:31:26.000Z</published>
    <updated>2018-01-14T12:57:26.376Z</updated>
    
    <content type="html"><![CDATA[<p><strong>虚拟机规范把类加载阶段中的“通过一个类的全限定名（包名加类名）来获取描述此类的二进制字节流”这个动作放到JVM外部实现</strong>，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块成为“<strong>类加载器</strong>”。</p><p>类加载器可以说是Java语言的一项创新，也是Java语言流行的重要原因之一，其最初是为了满足Java Applet的需求开发出来的。虽然Applet现在基本已经死了，但是类加载器却在层次划分、OSGi、热部署、代码加密等领域大放光彩，成为Java技术体系中的一块重要基石。</p><a id="more"></a><h2 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h2><p>类加载器虽然只用于实现类的加载操作，但是它在Java中起到的作用却远远不限于类加载阶段。对任意一个类，都需要由它的类加载器和这个类本身一同确立其在JVM中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更加通俗一些：<strong>比较这两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类就必定不相等</strong>。</p><p>比如下面这段代码。我们通过重写loadClass()方法自己定义了一个类加载器，并用这个类加载器去加载test.ClassLoaderTest这个类。结果加载这个类后实例化的对象instanceof ClassLoaderTest的结果位false。因为虚拟机中存在了两个ClassLoaderTest类，一个是由系统应用程序类加载器加载的，另外一个是由我们自定义的类加载器加载的，<strong>虽然都来自同一个Class文件，但依然是两个独立的类</strong>，做对象所属类型检查时自然为false。</p><p>可以理解为，Class文件＋加载它的类加载器＝类加载进JVM的唯一标识。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException </span>&#123;</span><br><span class="line">        ClassLoader myLoader = <span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String className = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 返回读取指定资源的输入流</span></span><br><span class="line">                    InputStream is = getClass().getResourceAsStream(className);</span><br><span class="line">                    <span class="keyword">if</span> (is == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">                    is.read(b);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 将一个byte数组转换为Class类的实例</span></span><br><span class="line">                    <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Object object = myLoader.loadClass(<span class="string">"test.ClassLoaderTest"</span>).newInstance();</span><br><span class="line">        System.out.println(object.getClass());</span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> test.ClassLoaderTest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class test.ClassLoaderTest</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>从JVM的角度来讲，只存在2种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++实现，是JVM本身的一部分；另一个种就是所有其他的类加载器，这个类加载器都是Java实现，独立于JVM外部，并且全部继承自抽象类java.lang.ClassLoader。</p><p>从Java开发人员的角度来看，类加载器还可以划分得更加细致一些，绝大部份Java程序都会使用到一下3种系统提供的类加载器。</p><ul><li>启动类加载器：负责将存放在JAVA_HOME/lib目录中的，或者被-Xbootclasspath参数所指定的路径中的（基本上是负责加载Java的核心类），并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那么直接使用null代替即可（java.lang.ClassLoader中的getClassLoader()方法直接返回null）。启动类加载器不是java.lang.ClassLoader的子类，而是由JVM自身实现，用C++编写。</li><li>扩展类加载器：负责加载JAVA_HOME/lib/ext目录中，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。Java实现。</li><li>应用程序类加载器：这个类加载器是java.lang.ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称为系统类加载器。它负责加载用户路径（classpath）上所指定的类库，开发者可以直接使用这个类加载器，<strong>如果应用程序中没有自定义过自己的类加载器，那么这个就是程序中默认的类加载器</strong>。</li></ul><p>用户的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。这些类加载器之间的关系如下图所示。</p><p><img src="/img/20160506184936657.jpg" alt=""></p><p>图中展示的类加载器之间的这种层次关系，称为类加载器的<strong>双亲委派模型</strong>。双亲委派模型要求除了顶层的启动类加载器，其余的类加载器都要有自己的父类加载器。这里类加载器之间的父子关系一般不会以集成的关系来实现，而都是以组合关系来复用父类加载器的代码。</p><p><strong>双亲委派模型并不是一个强制性的约束模型，而是Java设计者推荐给开发者的一种类加载器实现方式</strong>。</p><p>双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，因此所有的加载请求最终都应该传递到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（<strong>它的搜索范围内没有找到所需的类</strong>）时，子加载器才会尝试自己去加载。</p><p>使用双亲委派模型的好处就是，Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如Object类，它存放在rt.jar（runtime）中，无论哪个类加载器都要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object在程序的各种类加载器中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器去加载，如果用户自己编写了一个Object并放在classpath中，那么系统将出现多个不同的Object类，Java类体系中最基础的行为就无法保证，将变得一片混乱。编写一个与rt.jar中已有类重名的类，将会发现可以编译（因为是不同类加载器加载），但是永远无法被加载运行。</p><p><strong>双亲委派模型对保证Java程序正常运行非常重要</strong>。其实现很简单（如下面代码）：在java.lang.ClassLoader的loadClass()方法中，先检查类是否已经被加载过，若没有加载则调用父加载器的loadClass()方法，若父类加载器为空则默认使用启动类加载器作为父类加载器。如果父类加载失败，则调用自己的findClass()方法进行加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义的ClassLoader"><a href="#自定义的ClassLoader" class="headerlink" title="自定义的ClassLoader"></a>自定义的ClassLoader</h2><ol><li>loadClass(String name,boolean resolve) 根据指定的二进制名称加载类</li><li>findClass(String name) 根据二进制名称来查找类</li><li>可以直接使用或继承已有的ClassLoader实现：java.net.URLClassLoader、 java.security.SecureClassLoader、 java.rmi.server.RMIClassLoader</li><li>按照双亲委派模型方式，在调用loadClass方法时，会先尝试在最高层的父加载器中加载，如果加载失败，则会调用自己的findClass方法来完成加载</li></ol><h2 id="打破双亲委派模型"><a href="#打破双亲委派模型" class="headerlink" title="打破双亲委派模型"></a>打破双亲委派模型</h2><p>双亲委派模型并不是一个强制性的约束模型，而是Java设计者推荐给开发者的类加载器的实现方式。如果没有按照这个模型，则称打破双亲委派模型。</p><p>从前面java.lang.ClassLoader的loadClass()方法可以看出，双亲委派模型的具体逻辑就在这个方法之中。因此，不提倡用户再去重写loadClass()方法，而应当把自定义类加载逻辑放倒findClass()方法中，在loadClass()方法的逻辑里如果父类加载失败，则会调用自己的findClass()方法来完成加载，这样就可以保证新写出的类加载器是符合双亲委派模型的。当然，重写loadClass()方法并让其遵循双亲委派模型也可以，但是这样有点多此一举，因为那个架子人家搭得已经非常好了。</p><p>如果要打破双亲委派模型，这个自定义的类加载器也必须是特殊的。由于系统自带的三个类加载器都加载特定目录下的类，如果自定义的类加载器放在一个特殊的目录，那么系统的加载器就无法加载它，会导致最终还是由系统的类加载器来加载，这样就还是遵循双亲委派模型。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;虚拟机规范把类加载阶段中的“通过一个类的全限定名（包名加类名）来获取描述此类的二进制字节流”这个动作放到JVM外部实现&lt;/strong&gt;，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块成为“&lt;strong&gt;类加载器&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;类加载器可以说是Java语言的一项创新，也是Java语言流行的重要原因之一，其最初是为了满足Java Applet的需求开发出来的。虽然Applet现在基本已经死了，但是类加载器却在层次划分、OSGi、热部署、代码加密等领域大放光彩，成为Java技术体系中的一块重要基石。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://lioncruise.github.io/categories/JVM/"/>
    
    
      <category term="Java" scheme="http://lioncruise.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="http://lioncruise.github.io/tags/JVM/"/>
    
      <category term="Java类加载" scheme="http://lioncruise.github.io/tags/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存分配回收策略</title>
    <link href="http://lioncruise.github.io/2016/02/06/JVM-memory-strategy/"/>
    <id>http://lioncruise.github.io/2016/02/06/JVM-memory-strategy/</id>
    <published>2016-02-06T15:18:40.000Z</published>
    <updated>2018-01-14T12:56:43.356Z</updated>
    
    <content type="html"><![CDATA[<p>Java的自动内存管理最终可以归结为 自动化 地解决了两个问题：对象内存分配、回收分配给对象的内存。</p><a id="more"></a><h2 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h2><p>大多数情况下，对象在新生代Eden区中分配。当Eden区中没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p><p>新生代分为1个Eden空间和2个Survivor空间，默认比例为8:1:1。新生代总可使用空间为1个Eden和1个Survivor的大小。</p><p>分配担保机制：新生代Survivor区空间不够，直接将对象提前转移到老年代上去。</p><ul><li>Minor GC（新生代GC）：指发生在新生代的GC操作，因为Java对象大多数都具备朝生夕死的特点，所以Minor GC非常频繁，一般回收速度也非常快</li><li>Full GC（老年代GC）：指发生在老年代的GC。出现了Full GC，经常会伴随至少一次的Minor GC（但不是绝对的）。Full GC的速度一般会比Minor GC慢10倍以上（因为回收率很低）。</li></ul><h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><p>所谓的大对象，指的是需要大量连续内存空间的Java对象。最典型的大对象就是那种很长的字符串、数组。</p><p>JVM设置了一个 -XX:PretenureSizeThreshold参数，令大于这个值的对象直接进入老年代分配。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存复制操作。</p><h2 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h2><p>JVM给每个对象定义了一个 年龄计数器。如果对象在Eden出生并经过一次Minor GC后仍存活，并且能被Survivor容纳的话，将被移动到Survivor空间，并且对象年龄加1。对象在Survivor区每熬过一次Minor GC，年龄就会增加1。当它的年龄增加到一定程度（默认为15岁），就会晋升到老年代中。</p><p>对象晋升老年代的阀值，可以通过参数 -XX:MaxTenuringThreshold设置。</p><h2 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h2><p>为了能更好地适应不同程序的内存情况，虚拟机并不是永远地要求对象年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象的大小总和大于Survivor空间一半的时候，年龄大于等于该年龄对象的对象就可以直接进入老年代，无需年龄要求。</p><h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><p>在发生Minor GC之前，JVM会先检查 <strong>老年代</strong> 最大可用的连续空间是否大于新生代所有对象总空间。如果这个条件成立，那么Minor GC可以确认是安全的。如果不成立，JVM会查看HandlePromotionFailure设置值是否允许 <strong>担保失败</strong>。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均值，如果大于，将尝试进行一次Minor GC，尽管这次GC是有风险的；如果小于，或设置为不允许冒险，那这是也要改为进行一次Full GC。</p><p>空间分配担保：Minor GC，Survivor空间可能不够，要老年代给其担保。Survivor空间装不下的，直接放到老年代。</p><p>一般Survivor空间是很小的，老年代空间很大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java的自动内存管理最终可以归结为 自动化 地解决了两个问题：对象内存分配、回收分配给对象的内存。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://lioncruise.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://lioncruise.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="http://lioncruise.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>为什么要使用动态代理？</title>
    <link href="http://lioncruise.github.io/2015/12/01/jdk-dynamic-proxy/"/>
    <id>http://lioncruise.github.io/2015/12/01/jdk-dynamic-proxy/</id>
    <published>2015-12-01T02:44:10.000Z</published>
    <updated>2018-01-14T12:56:06.237Z</updated>
    
    <content type="html"><![CDATA[<p>首先，我来看一下设计模式中常见的代理模式，也就是所谓的静态代理。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"call doSomething()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubjectProxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    Subject subimpl = <span class="keyword">new</span> RealSubject();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before doSomething()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after doSomething()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理RealSubject的doSomething()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span>前置增强</span></span><br><span class="line">        before();</span><br><span class="line"></span><br><span class="line">        subimpl.doSomething();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span>后置增强</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Subject sub = <span class="keyword">new</span> SubjectProxy();</span><br><span class="line">        sub.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种模式通过代理类对原来类的方法实现了封装和增强，即在原来的方法的前后嵌入代码片段。这种方法比较容易看懂，但是静态代理的这种写法有一个很大的问题，就是在一个类要增强的方法越来越多的时候，代理需要分别对每个方法进行增强，这样使代理类的代码量非常庞大。</p><p>因此，就引入了动态代理来解决这个问题。看一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"call doSomething 1()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"call doSomething 2()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object tar;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before call"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after call"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定委托对象，并返回代理类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object tar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tar = tar;</span><br><span class="line">        <span class="comment">// 绑定该类实现的所有接口，取得代理类</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(tar.getClass().getClassLoader(), tar.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 这里就可以进行所谓的AOP编程了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span>前置增强</span></span><br><span class="line">        before();</span><br><span class="line"></span><br><span class="line">        result = method.invoke(tar, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span>后置增强</span></span><br><span class="line">        after();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        ProxyHandler proxy = <span class="keyword">new</span> ProxyHandler();</span><br><span class="line">        <span class="comment">// 绑定该类实现的所有接口</span></span><br><span class="line">        Subject sub = (Subject) proxy.bind(<span class="keyword">new</span> RealSubject());</span><br><span class="line">        sub.doSomething1();</span><br><span class="line">        sub.doSomething2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">before call</span><br><span class="line">call doSomething 1()</span><br><span class="line">after call</span><br><span class="line">before call</span><br><span class="line">call doSomething 2()</span><br><span class="line">after call</span><br></pre></td></tr></table></figure><p>看完这段代码，相信大家应该已经非常清楚Java动态代理的作用了。<strong>就是将Proxy类的代码量固定下来，不会因为被代理类的业务逐渐增大而增大</strong>。</p><p>实际上，Spring的AOP和AspectJ就是基于动态代理技术实现的，而且它们能在配置文件中设置一些信息使代理更好用，更灵活。这也是Spring为什么这么受欢迎的原因之一，用SpringAOP代替JDK动态代理，让面向切面编程更容易实现。</p><p>现在Java的动态代理主要分为Java自己提供的JDK动态代理和CGLib(Code Generation Library)。JDK动态代理只能代理接口类，而CGLib这种则是直接修改字节码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，我来看一下设计模式中常见的代理模式，也就是所谓的静态代理。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://lioncruise.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://lioncruise.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>对Java反射机制的一点见解</title>
    <link href="http://lioncruise.github.io/2015/11/29/java-reflection/"/>
    <id>http://lioncruise.github.io/2015/11/29/java-reflection/</id>
    <published>2015-11-29T13:32:15.000Z</published>
    <updated>2018-01-14T12:55:40.789Z</updated>
    
    <content type="html"><![CDATA[<p>首先，从动态语言讲起。像Python、Ruby这种语言，只要修改了代码，修改的效果立即生效，因为这种语言是无需编译，直接执行代码的，我们称这类语言是“动态语言”。而C++、Java这种，在运行之前需要先编译，如果中途修改了代码不重新编译去执行的话就没有变化。但是，Java有一个非常突出的动态相关机制，即反射：我们可以于运行时（区别于编译时）加载、探知、使用编译期间完全未知的classes。换句话说，Java程序可以加载一个运行时才得知名称的class（在这之前修改这个类即时不编译都有效），获悉其完整构造（但不包括methods定义），并生成其对象实体、或对其fields设值、或唤起其methods。</p><a id="more"></a><p>再通俗地说一下什么是反射？</p><p>普通的Java对象是通过new关键字把对应类的字节码文件加载到内存，然后创建该对象的。</p><p>反射是通过一个名为Class的特殊类，用Class.forName(“类名”);得到类的字节码对象，然后用newInstance()方法在虚拟机内部构造这个对象（针对无参构造函数）。</p><p><strong>也就是说反射机制让我们可以在程序运行时动态地拿到Java类对应的字节码对象（而不是在编译的时候）</strong>，然后动态的进行任何可能的操作。反射的功能主要包括：</p><ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的方法（这样就可以修改这个对象的属性）</li><li>生成动态代理</li></ul><p><strong>使用反射的主要作用是方便程序的扩展</strong>，由于其运行时动态加载的特性。</p><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>Java中只有2种东西不是面向对象的，一个基本类型，一个静态成员（方法、变量、常量）。<strong>我们提供的每一个类也是对象，一个类的类类型是java.lang.Class类的实例对象</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建类Foo的实例对象</span></span><br><span class="line">Foo foo1 = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Foo这个类也是一个实例对象，Class类的实例对象</span></span><br><span class="line"><span class="comment">// 任何一个类都是Class的实例对象，这个实例对象有三种表达方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种表达方式。实际上表明任何一个类都有一个隐含的静态成员变量Class</span></span><br><span class="line">Class c1 = Foo.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种表达方式</span></span><br><span class="line">Class c2 = foo1.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据官网说法，c1,c2表示了Foo类的类类型(class type)</span></span><br><span class="line"><span class="comment">// 类也是对象，是Class类的实例对象，这个对象我们成为该类的类类型</span></span><br><span class="line"></span><br><span class="line">System.out.println(c1==c2)   <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第三种表达方式</span></span><br><span class="line">Class c3 = Class.forName(<span class="string">"Foo"</span>);</span><br><span class="line"> </span><br><span class="line">System.out.println(c1==c3)   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Class类的构造器是私有的，只能JVM能创建Class类的实例对象。</p><p>可以通过类类型 (上面的c1 c2 c3)创建Foo类的实例对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo foo = (Foo)c1.newInstance();</span><br></pre></td></tr></table></figure><h2 id="动态加载类"><a href="#动态加载类" class="headerlink" title="动态加载类"></a>动态加载类</h2><p>什么是动态加载？什么是静态加载？</p><p><strong>静态加载的类在编译的时候就要提供，而动态加载的类在源程序编译时可以缺席</strong>。区分编译时和运行时。</p><p>Class.forName(“类名”) 这种方式，不仅表示了类的类类型，还代表了动态加载类。</p><p>用new这种方式静态加载方式，编译的时候，如果new的对象的那个类不存在的话，编译不通过；但是用Class.forName这种动态加载方式，没有这个类编译的时候不会报任何错，但是运行的时候会因为找不到这个类而报错。动态加载有什么好处呢？配合接口编程，可以实现一个接口对多种实现，从而可以动态地去选择完成不同的功能。因此，<strong>类动态加载对扩展功能很有用</strong>。</p><p><strong>其实，动态类加载主要就是通过反射机制将类对象注入进去。</strong></p><p>静态加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Office_Static</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//new 创建对象，是静态加载类，在编译时刻就需要用到Word和Excel，并将其编译</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"Word"</span>.equals(args[<span class="number">0</span>]))&#123;  </span><br><span class="line">            Word w = <span class="keyword">new</span> Word();  </span><br><span class="line">            w.start();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"Excel"</span>.equals(args[<span class="number">0</span>]))&#123;  </span><br><span class="line">            Excel e = <span class="keyword">new</span> Excel();  </span><br><span class="line">            e.start();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OfficeAble</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Word</span> <span class="keyword">implements</span> <span class="title">OfficeAble</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"word start"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Excel</span> <span class="keyword">implements</span> <span class="title">OfficeAble</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"excel start"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OfficeBetter</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">//动态加载类，在运行时刻才要用这个类  </span></span><br><span class="line">            Class c = Class.forName(args[<span class="number">0</span>]);<span class="comment">//在运行配置里面输入com.imooc.加载类.Excel  </span></span><br><span class="line">            <span class="comment">//通过类类型，创建该类对象(先转换为Word和Excel的共同接口OfficeAble)  </span></span><br><span class="line">            OfficeAble oa = (OfficeAble)c.newInstance();  </span><br><span class="line">            oa.start();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过反射动态获取对象的方法属性构造器信息"><a href="#通过反射动态获取对象的方法属性构造器信息" class="headerlink" title="通过反射动态获取对象的方法属性构造器信息"></a>通过反射动态获取对象的方法属性构造器信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印类的信息，包括类的成员函数、成员变量(只获取成员函数)</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     *            该对象所属类的信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClassMethodMessage</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 要获取类的信息 首先要获取类的类类型</span></span><br><span class="line">        Class c = obj.getClass();<span class="comment">// 传递的是哪个子类的对象 c就是该子类的类类型</span></span><br><span class="line">        <span class="comment">// 获取类的名称</span></span><br><span class="line">        System.out.println(<span class="string">"类的名称是:"</span> + c.getName());</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Method类，方法对象 一个成员方法就是一个Method对象</span></span><br><span class="line"><span class="comment">         * getMethods()方法获取的是所有的public的函数，包括父类继承而来的</span></span><br><span class="line"><span class="comment">         * getDeclaredMethods()获取的是所有该类自己声明的方法，不问访问权限</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Method[] ms = c.getMethods();<span class="comment">// c.getDeclaredMethods()</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ms.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 得到方法的返回值类型的类类型</span></span><br><span class="line">            Class returnType = ms[i].getReturnType();</span><br><span class="line">            System.out.print(returnType.getName() + <span class="string">" "</span>);</span><br><span class="line">            <span class="comment">// 得到方法的名称</span></span><br><span class="line">            System.out.print(ms[i].getName() + <span class="string">"("</span>);</span><br><span class="line">            <span class="comment">// 获取参数类型---&gt;得到的是参数列表的类型的类类型</span></span><br><span class="line">            Class[] paramTypes = ms[i].getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (Class class1 : paramTypes) &#123;</span><br><span class="line">                System.out.print(class1.getName() + <span class="string">","</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取成员变量的信息</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFieldMessage</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        Class c = obj.getClass();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 成员变量也是对象 java.lang.reflect.Field Field类封装了关于成员变量的操作</span></span><br><span class="line"><span class="comment">         * getFields()方法获取的是所有的public的成员变量的信息</span></span><br><span class="line"><span class="comment">         * getDeclaredFields获取的是该类自己声明的成员变量的信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// Field[] fs = c.getFields();</span></span><br><span class="line">        Field[] fs = c.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fs) &#123;</span><br><span class="line">            <span class="comment">// 得到成员变量的类型的类类型</span></span><br><span class="line">            Class fieldType = field.getType();</span><br><span class="line">            String typeName = fieldType.getName();</span><br><span class="line">            <span class="comment">// 得到成员变量的名称</span></span><br><span class="line">            String fieldName = field.getName();</span><br><span class="line">            System.out.println(typeName + <span class="string">" "</span> + fieldName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印对象的构造函数的信息</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printConMessage</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        Class c = obj.getClass();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 构造函数也是对象 java.lang. Constructor中封装了构造函数的信息</span></span><br><span class="line"><span class="comment">         * getConstructors获取所有的public的构造函数 getDeclaredConstructors得到所有的构造函数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// Constructor[] cs = c.getConstructors();</span></span><br><span class="line">        Constructor[] cs = c.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : cs) &#123;</span><br><span class="line">            System.out.print(constructor.getName() + <span class="string">"("</span>);</span><br><span class="line">            <span class="comment">// 获取构造函数的参数列表---&gt;得到的是参数列表的类类型</span></span><br><span class="line">            Class[] paramTypes = constructor.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (Class class1 : paramTypes) &#123;</span><br><span class="line">                System.out.print(class1.getName() + <span class="string">","</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过反射运行时动态调用对象的方法"><a href="#通过反射运行时动态调用对象的方法" class="headerlink" title="通过反射运行时动态调用对象的方法"></a>通过反射运行时动态调用对象的方法</h2><p>用<strong>方法对象</strong>进行反射操作，运行时动态调用一个对象的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 要获取print(int ,int )方法 1.要获取一个方法就是获取类的信息，获取类的信息首先要获取类的类类型</span></span><br><span class="line">        A a1 = <span class="keyword">new</span> A();</span><br><span class="line">        Class c = a1.getClass();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 2.获取方法 名称和参数列表来决定 getMethod获取的是public的方法 getDelcaredMethod自己声明的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Method m = c.getMethod("print", new</span></span><br><span class="line">            <span class="comment">// Class[]&#123;int.class,int.class&#125;);</span></span><br><span class="line">            Method m = c.getMethod(<span class="string">"print"</span>, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 方法的反射操作</span></span><br><span class="line">            <span class="comment">// a1.print(10, 20);方法的反射操作是用m对象来进行方法调用 和a1.print调用的效果完全相同</span></span><br><span class="line">            <span class="comment">// 方法如果没有返回值返回null,有返回值返回具体的返回值</span></span><br><span class="line">            <span class="comment">// Object o = m.invoke(a1,new Object[]&#123;10,20&#125;);</span></span><br><span class="line">            Object o = m.invoke(a1, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">            System.out.println(<span class="string">"=================="</span>);</span><br><span class="line">            <span class="comment">// 获取方法print(String,String)</span></span><br><span class="line">            Method m1 = c.getMethod(<span class="string">"print"</span>, String.class, String.class);</span><br><span class="line">            <span class="comment">// 用方法进行反射操作</span></span><br><span class="line">            <span class="comment">// a1.print("hello", "WORLD");</span></span><br><span class="line">            o = m1.invoke(a1, <span class="string">"hello"</span>, <span class="string">"WORLD"</span>);</span><br><span class="line">            System.out.println(<span class="string">"==================="</span>);</span><br><span class="line">            <span class="comment">// Method m2 = c.getMethod("print", new Class[]&#123;&#125;);</span></span><br><span class="line">            Method m2 = c.getMethod(<span class="string">"print"</span>);</span><br><span class="line">            <span class="comment">// m2.invoke(a1, new Object[]&#123;&#125;);</span></span><br><span class="line">            m2.invoke(a1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"helloworld"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(a + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        System.out.println(a.toUpperCase() + <span class="string">","</span> + b.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过反射了解Java泛型的本质"><a href="#通过反射了解Java泛型的本质" class="headerlink" title="通过反射了解Java泛型的本质"></a>通过反射了解Java泛型的本质</h2><p>反射的操作都是编译之后的操作，反射动态加载的类是在程序运行时编译并加载的。来看看下面这个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodDemo2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list1.add(<span class="string">"hello"</span>);</span><br><span class="line">        <span class="comment">//list1.add(20);错误的</span></span><br><span class="line">        Class c1 = list.getClass();</span><br><span class="line">        Class c2 = list1.getClass();</span><br><span class="line">        System.out.println(c1 == c2);<span class="comment">// 都是ArrayList的类类型，true</span></span><br><span class="line">        <span class="comment">//反射的操作都是编译之后的操作</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * c1==c2结果返回true说明编译之后集合的泛型是去泛型化的</span></span><br><span class="line"><span class="comment">         * Java中集合的泛型，是防止错误输入的，只在编译阶段有效，</span></span><br><span class="line"><span class="comment">         * 绕过编译就无效了</span></span><br><span class="line"><span class="comment">         * 验证：我们可以通过方法的反射来操作，绕过编译</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method m = c2.getMethod(<span class="string">"add"</span>, Object.class);</span><br><span class="line">            m.invoke(list1, <span class="number">20</span>);<span class="comment">//绕过编译操作就绕过了泛型</span></span><br><span class="line">            System.out.println(list1.size());</span><br><span class="line">            System.out.println(list1);</span><br><span class="line">            <span class="comment">/*for (String string : list1) &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(string);</span></span><br><span class="line"><span class="comment">            &#125;*/</span><span class="comment">//现在不能这样遍历</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，从动态语言讲起。像Python、Ruby这种语言，只要修改了代码，修改的效果立即生效，因为这种语言是无需编译，直接执行代码的，我们称这类语言是“动态语言”。而C++、Java这种，在运行之前需要先编译，如果中途修改了代码不重新编译去执行的话就没有变化。但是，Java有一个非常突出的动态相关机制，即反射：我们可以于运行时（区别于编译时）加载、探知、使用编译期间完全未知的classes。换句话说，Java程序可以加载一个运行时才得知名称的class（在这之前修改这个类即时不编译都有效），获悉其完整构造（但不包括methods定义），并生成其对象实体、或对其fields设值、或唤起其methods。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://lioncruise.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://lioncruise.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
